<html>
<head>
<title>sandbox.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sandbox.py</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0"># base Vizard libraries</span>
<a name="l2"><span class="ln">2    </span></a><span class="s2">import </span><span class="s1">viz</span>
<a name="l3"><span class="ln">3    </span></a><span class="s2">import </span><span class="s1">vizshape</span>
<a name="l4"><span class="ln">4    </span></a><span class="s2">import </span><span class="s1">vizact</span>
<a name="l5"><span class="ln">5    </span></a><span class="s2">import </span><span class="s1">copy  </span><span class="s0"># used for copying the contents of a list/dictionary variable without referencing the original variable</span>
<a name="l6"><span class="ln">6    </span></a>
<a name="l7"><span class="ln">7    </span></a><span class="s2">import </span><span class="s1">config</span>
<a name="l8"><span class="ln">8    </span></a><span class="s2">from </span><span class="s1">globalFunctions </span><span class="s2">import </span><span class="s3">*</span>
<a name="l9"><span class="ln">9    </span></a><span class="s2">import </span><span class="s1">myGUI</span>
<a name="l10"><span class="ln">10   </span></a>
<a name="l11"><span class="ln">11   </span></a><span class="s0"># in the beginning, always ask the user if they want to load the data from exportData</span>
<a name="l12"><span class="ln">12   </span></a><span class="s2">while True</span><span class="s3">:  </span><span class="s0"># if the user doesn't input 'y' or 'n', loop forever until they do so</span>
<a name="l13"><span class="ln">13   </span></a>    <span class="s1">imports </span><span class="s3">= </span><span class="s1">input</span><span class="s3">(</span><span class="s4">'Import from exportData? (y / n): '</span><span class="s3">)</span>
<a name="l14"><span class="ln">14   </span></a>    <span class="s2">if </span><span class="s1">imports</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">() == </span><span class="s4">'y'</span><span class="s3">:</span>
<a name="l15"><span class="ln">15   </span></a>        <span class="s1">imports </span><span class="s3">= </span><span class="s2">True</span>
<a name="l16"><span class="ln">16   </span></a>    <span class="s2">elif </span><span class="s1">imports</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">() == </span><span class="s4">'n'</span><span class="s3">:</span>
<a name="l17"><span class="ln">17   </span></a>        <span class="s1">imports </span><span class="s3">= </span><span class="s2">False</span>
<a name="l18"><span class="ln">18   </span></a>    <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">imports</span><span class="s3">) </span><span class="s2">is </span><span class="s1">bool</span><span class="s3">:</span>
<a name="l19"><span class="ln">19   </span></a>        <span class="s2">break</span>
<a name="l20"><span class="ln">20   </span></a>    <span class="s2">else</span><span class="s3">:</span>
<a name="l21"><span class="ln">21   </span></a>        <span class="s1">print</span><span class="s3">(</span><span class="s4">'Please enter y / n!'</span><span class="s3">)</span>
<a name="l22"><span class="ln">22   </span></a>
<a name="l23"><span class="ln">23   </span></a><span class="s0"># Vizard window initialization</span>
<a name="l24"><span class="ln">24   </span></a><span class="s1">viz</span><span class="s3">.</span><span class="s1">setMultiSample</span><span class="s3">(</span><span class="s5">4</span><span class="s3">)  </span><span class="s0"># FSAA (Full Screen Anti-Aliasing) resolution</span>
<a name="l25"><span class="ln">25   </span></a><span class="s1">viz</span><span class="s3">.</span><span class="s1">fov</span><span class="s3">(</span>
<a name="l26"><span class="ln">26   </span></a>    <span class="s5">90</span><span class="s3">)  </span><span class="s0"># FoV (Field of View) (increased from the default value of 60 to 90 to allow more things to be seen by the camera at once)</span>
<a name="l27"><span class="ln">27   </span></a><span class="s1">viz</span><span class="s3">.</span><span class="s1">go</span><span class="s3">()  </span><span class="s0"># initialise the Vizard game windown</span>
<a name="l28"><span class="ln">28   </span></a>
<a name="l29"><span class="ln">29   </span></a><span class="s4">&quot;&quot;&quot; 
<a name="l30"><span class="ln">30   </span></a>'controlsConf' will be used to query the Vizard hand objects for getting their button pressed. 
<a name="l31"><span class="ln">31   </span></a>'controls' will be used to query the hands for their positions. 
<a name="l32"><span class="ln">32   </span></a>the correct controls file for importing is indicated by the mode ('keyboard/mouse' / 'VR' as 'k' / 'vr', respectively). 
<a name="l33"><span class="ln">33   </span></a>&quot;&quot;&quot;</span>
<a name="l34"><span class="ln">34   </span></a><span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'vr'</span><span class="s3">:</span>
<a name="l35"><span class="ln">35   </span></a>    <span class="s2">import </span><span class="s1">steamVR_init </span><span class="s2">as </span><span class="s1">controlsConf</span>
<a name="l36"><span class="ln">36   </span></a><span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'k'</span><span class="s3">:</span>
<a name="l37"><span class="ln">37   </span></a>    <span class="s2">if </span><span class="s1">fullscreen</span><span class="s3">:  </span><span class="s0"># only allow full-screen if on k/m, since it breaks stuff in VR</span>
<a name="l38"><span class="ln">38   </span></a>        <span class="s1">viz</span><span class="s3">.</span><span class="s1">window</span><span class="s3">.</span><span class="s1">setFullscreen</span><span class="s3">()</span>
<a name="l39"><span class="ln">39   </span></a>    <span class="s2">import </span><span class="s1">keyboard_mouse_init </span><span class="s2">as </span><span class="s1">controlsConf</span>
<a name="l40"><span class="ln">40   </span></a><span class="s1">controls </span><span class="s3">= </span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">Main</span><span class="s3">()</span>
<a name="l41"><span class="ln">41   </span></a>
<a name="l42"><span class="ln">42   </span></a><span class="s0"># 'l/rControllerObj' are constants used for interacting with GUIs by passing these into classes in myGUI whenever GUIs are summoned</span>
<a name="l43"><span class="ln">43   </span></a><span class="s1">lControllerObj </span><span class="s3">= [</span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>
<a name="l44"><span class="ln">44   </span></a><span class="s1">rControllerObj </span><span class="s3">= [</span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]]</span>
<a name="l45"><span class="ln">45   </span></a>
<a name="l46"><span class="ln">46   </span></a><span class="s1">viz</span><span class="s3">.</span><span class="s1">vsync</span><span class="s3">(</span>
<a name="l47"><span class="ln">47   </span></a>    <span class="s5">0</span><span class="s3">)  </span><span class="s0"># disable vsync (cuz it caps off max calcs/second) to the display's refresh rate. unfortunately doesn't work for VR.</span>
<a name="l48"><span class="ln">48   </span></a>
<a name="l49"><span class="ln">49   </span></a>
<a name="l50"><span class="ln">50   </span></a><span class="s0"># generalized control function to get if the 'select' button is being pressed, given a controller's index (0==left, 1==right)</span>
<a name="l51"><span class="ln">51   </span></a><span class="s2">def </span><span class="s1">selectP</span><span class="s3">(</span><span class="s1">cIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
<a name="l52"><span class="ln">52   </span></a>    <span class="s2">return </span><span class="s1">buttonPressed</span><span class="s3">(</span><span class="s4">'select'</span><span class="s3">, </span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s1">cIdx</span><span class="s3">], </span><span class="s1">cIdx</span><span class="s3">)</span>
<a name="l53"><span class="ln">53   </span></a>
<a name="l54"><span class="ln">54   </span></a>
<a name="l55"><span class="ln">55   </span></a><span class="s0"># this method is used to generalize slider/manual inputs with similar parameters</span>
<a name="l56"><span class="ln">56   </span></a><span class="s2">def </span><span class="s1">getSliderManual</span><span class="s3">(</span><span class="s1">xyz</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">referenceVar</span><span class="s3">, </span><span class="s1">globalDefaultVar</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">: </span><span class="s1">list</span><span class="s3">, </span><span class="s1">length</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">maxi</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">mini</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
<a name="l57"><span class="ln">57   </span></a>                    <span class="s1">text</span><span class="s3">) </span><span class="s1">-&gt; object</span><span class="s3">:</span>
<a name="l58"><span class="ln">58   </span></a>    <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'vr'</span><span class="s3">:</span>
<a name="l59"><span class="ln">59   </span></a>        <span class="s2">return </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Slider</span><span class="s3">(</span><span class="s1">xyz</span><span class="s3">, </span><span class="s1">referenceVar</span><span class="s3">, </span><span class="s1">globalDefaultVar</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">maxi</span><span class="s3">, </span><span class="s1">mini</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">lControllerObj</span><span class="s3">,</span>
<a name="l60"><span class="ln">60   </span></a>                            <span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l61"><span class="ln">61   </span></a>    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'k'</span><span class="s3">:</span>
<a name="l62"><span class="ln">62   </span></a>        <span class="s2">return </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Manual</span><span class="s3">(</span><span class="s1">xyz</span><span class="s3">, </span><span class="s1">referenceVar</span><span class="s3">, </span><span class="s1">globalDefaultVar</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">lControllerObj</span><span class="s3">, </span><span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l63"><span class="ln">63   </span></a>
<a name="l64"><span class="ln">64   </span></a>
<a name="l65"><span class="ln">65   </span></a><span class="s0"># Main class for sandbox.py</span>
<a name="l66"><span class="ln">66   </span></a><span class="s2">class </span><span class="s1">Main</span><span class="s3">:</span>
<a name="l67"><span class="ln">67   </span></a>    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l68"><span class="ln">68   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">pause </span><span class="s3">= </span><span class="s2">False  </span><span class="s0"># stores if physics should be paused (all points have 0 velocity if True)</span>
<a name="l69"><span class="ln">69   </span></a>
<a name="l70"><span class="ln">70   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">points </span><span class="s3">= []  </span><span class="s0"># list of points for the whole program</span>
<a name="l71"><span class="ln">71   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">diff </span><span class="s3">= []  </span><span class="s0"># cache variable to store the scalar distance between each point</span>
<a name="l72"><span class="ln">72   </span></a>
<a name="l73"><span class="ln">73   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">joints </span><span class="s3">= []  </span><span class="s0"># list of joints for the whole program</span>
<a name="l74"><span class="ln">74   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">collisionRect </span><span class="s3">= []  </span><span class="s0"># list of collision rectangles for the whole program</span>
<a name="l75"><span class="ln">75   </span></a>
<a name="l76"><span class="ln">76   </span></a>        <span class="s4">&quot;&quot;&quot; 
<a name="l77"><span class="ln">77   </span></a>        this is a dictionary of all GUIs and their possible forms in the notation: variable: {type: {axes: None}}, where None is replaced with the GUI object when they are summoned. 
<a name="l78"><span class="ln">78   </span></a>        for all scalar quantities, manual and slider inputs have only one axis: default ('X'). this is for two reasons: 
<a name="l79"><span class="ln">79   </span></a>            1) having no axes (no direction, since it's a scalar) means that, well... there aren't any axes; only magnitude! 
<a name="l80"><span class="ln">80   </span></a>            2) while slider and dial GUI types have axes regardless if a value is a vector or scalar quantity, that's only because their visuals can be affected by summoning them about different axes. manual inputs' visuals aren't affected by its axis! 
<a name="l81"><span class="ln">81   </span></a>        tutorials have an empty dictionary to allow tutorials to be updated to it from the importTutorials method, allowing for the selection of all tutorials from tutorialTexts 
<a name="l82"><span class="ln">82   </span></a>        &quot;&quot;&quot;</span>
<a name="l83"><span class="ln">83   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI </span><span class="s3">= {</span>
<a name="l84"><span class="ln">84   </span></a>            <span class="s4">'gameSpeed'</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l85"><span class="ln">85   </span></a>            <span class="s4">'gField'</span><span class="s3">: {</span><span class="s4">'dial'</span><span class="s3">: {</span><span class="s4">'XZ'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'XY'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'YZ'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'3D'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">},</span>
<a name="l86"><span class="ln">86   </span></a>                       <span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'Y'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'Z'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'Y'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'Z'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l87"><span class="ln">87   </span></a>            <span class="s4">'gasDensity'</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l88"><span class="ln">88   </span></a>            <span class="s4">'springConst'</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l89"><span class="ln">89   </span></a>            <span class="s4">'damping'</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l90"><span class="ln">90   </span></a>            <span class="s4">'friction'</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l91"><span class="ln">91   </span></a>            <span class="s4">'strain'</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'X'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},</span>
<a name="l92"><span class="ln">92   </span></a>            <span class="s4">'GUISelector'</span><span class="s3">: {</span><span class="s4">''</span><span class="s3">: {</span><span class="s4">''</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}},  </span><span class="s0"># this has empty strings since the GUI selector has no type or axes</span>
<a name="l93"><span class="ln">93   </span></a>            <span class="s4">'Tutorials'</span><span class="s3">: {</span><span class="s4">''</span><span class="s3">: {}}  </span><span class="s0"># this has empty strings since all tutorials have no type nor axes</span>
<a name="l94"><span class="ln">94   </span></a>        <span class="s3">}</span>
<a name="l95"><span class="ln">95   </span></a>
<a name="l96"><span class="ln">96   </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld </span><span class="s3">= {}  </span><span class="s0"># stores if a button is being held</span>
<a name="l97"><span class="ln">97   </span></a>        <span class="s0"># update buttonHeld to have all the controls from config.controls</span>
<a name="l98"><span class="ln">98   </span></a>        <span class="s2">for </span><span class="s1">cMap </span><span class="s2">in </span><span class="s1">config</span><span class="s3">.</span><span class="s1">controls</span><span class="s3">:</span>
<a name="l99"><span class="ln">99   </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">cMap</span><span class="s3">: [</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">]})</span>
<a name="l100"><span class="ln">100  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]  </span><span class="s0"># last clicked point index, which loses its value after deselecting a point</span>
<a name="l101"><span class="ln">101  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]  </span><span class="s0"># last clicked point index, which retains its value even after deselecting a point</span>
<a name="l102"><span class="ln">102  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__collP </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]  </span><span class="s0"># stores the indexes of points that are colliding with either controller</span>
<a name="l103"><span class="ln">103  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># visual scale of controller animations</span>
<a name="l104"><span class="ln">104  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScaleSpeed </span><span class="s3">= </span><span class="s5">0  </span><span class="s0"># rate at which animations scale</span>
<a name="l105"><span class="ln">105  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeColor </span><span class="s3">= [[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]]  </span><span class="s0"># stores the color of each controller's animation</span>
<a name="l106"><span class="ln">106  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType </span><span class="s3">= </span><span class="s2">None  </span><span class="s0"># holds the return value of GUISelector to create relevant GUI(s)</span>
<a name="l107"><span class="ln">107  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__clickTime </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">,</span>
<a name="l108"><span class="ln">108  </span></a>                            <span class="s5">0</span><span class="s3">]  </span><span class="s0"># stores time since 'select' was pressed for both controllers in order for double-click detection</span>
<a name="l109"><span class="ln">109  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__relPos </span><span class="s3">= [[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]]  </span><span class="s0"># stores the relative position of selected points with either controller</span>
<a name="l110"><span class="ln">110  </span></a>
<a name="l111"><span class="ln">111  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData </span><span class="s3">= {}  </span><span class="s0"># stores the indexes of all points in a cloth, with the cloth's name as the key</span>
<a name="l112"><span class="ln">112  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__tutorialTexts </span><span class="s3">= {}  </span><span class="s0"># stores all titles and contents of tutorials</span>
<a name="l113"><span class="ln">113  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__importTutorials</span><span class="s3">()</span>
<a name="l114"><span class="ln">114  </span></a>        <span class="s0"># if the user typed 'y', import from exportData</span>
<a name="l115"><span class="ln">115  </span></a>        <span class="s2">if </span><span class="s1">imports</span><span class="s3">:</span>
<a name="l116"><span class="ln">116  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__importData</span><span class="s3">()</span>
<a name="l117"><span class="ln">117  </span></a>
<a name="l118"><span class="ln">118  </span></a>    <span class="s0"># used to read the contents of exportData to allow the user to import their own creations from spriteCreator.py</span>
<a name="l119"><span class="ln">119  </span></a>    <span class="s2">def </span><span class="s1">__importData</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l120"><span class="ln">120  </span></a>        <span class="s1">f </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s4">'exportData'</span><span class="s3">, </span><span class="s4">'r'</span><span class="s3">)</span>
<a name="l121"><span class="ln">121  </span></a>        <span class="s1">data </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">read</span><span class="s3">().</span><span class="s1">splitlines</span><span class="s3">()</span>
<a name="l122"><span class="ln">122  </span></a>        <span class="s1">formattedData </span><span class="s3">= []  </span><span class="s0"># the code below makes this into the form: [[points], [joints], [collisionRects]]</span>
<a name="l123"><span class="ln">123  </span></a>        <span class="s1">f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
<a name="l124"><span class="ln">124  </span></a>        <span class="s4">&quot;&quot;&quot; 
<a name="l125"><span class="ln">125  </span></a>        step-by-step process of reading exportData: 
<a name="l126"><span class="ln">126  </span></a>            1. if the subsequent lines represent a different type (points/joints/collisionRects) to the previous line, append a new list to formattedData. 
<a name="l127"><span class="ln">127  </span></a>                the initial type is None, so the first line in exportData will always be 'POINTS'. 
<a name="l128"><span class="ln">128  </span></a>            2. until the next line represents a different type, append the current line to the latest list in formattedData. 
<a name="l129"><span class="ln">129  </span></a>            see below for point 3 onwards. 
<a name="l130"><span class="ln">130  </span></a>        &quot;&quot;&quot;</span>
<a name="l131"><span class="ln">131  </span></a>        <span class="s2">for </span><span class="s1">pjc </span><span class="s2">in </span><span class="s1">data</span><span class="s3">:  </span><span class="s0"># loop through all lines in exportData</span>
<a name="l132"><span class="ln">132  </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">pjc </span><span class="s3">== </span><span class="s4">'POINTS'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">pjc </span><span class="s3">== </span><span class="s4">'JOINTS'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">pjc </span><span class="s3">== </span><span class="s4">'COLLISIONRECTS'</span><span class="s3">):</span>
<a name="l133"><span class="ln">133  </span></a>                <span class="s1">formattedData</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([])</span>
<a name="l134"><span class="ln">134  </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l135"><span class="ln">135  </span></a>                <span class="s1">formattedData</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pjc</span><span class="s3">)</span>
<a name="l136"><span class="ln">136  </span></a>                <span class="s1">formattedData</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">formattedData</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">][-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">split</span><span class="s3">(</span><span class="s4">' | '</span><span class="s3">)</span>
<a name="l137"><span class="ln">137  </span></a>        <span class="s4">&quot;&quot;&quot; 
<a name="l138"><span class="ln">138  </span></a>            3. at this point, formattedData contains data in the form: [['points'], ['joints'], ['collisionRects']]. however, all this data is the literal string text from exportData. 
<a name="l139"><span class="ln">139  </span></a>                as such, the next steps will work on converting relevant values to lists, floats, and strings so that the program can recognize them as points/joints/collisionRects. 
<a name="l140"><span class="ln">140  </span></a>            4. go through each list in formattedData: 
<a name="l141"><span class="ln">141  </span></a>                a) 'i' represents the index of the type (0 == point, 1 == joint, 2 == collisionRect) 
<a name="l142"><span class="ln">142  </span></a>                b) 'j' represents the index of the object (point/joint/collisionRect) 
<a name="l143"><span class="ln">143  </span></a>                c) 'k' represents the index of the current element in the object (e.g. cords, radius, density, size) 
<a name="l144"><span class="ln">144  </span></a>            5. handle an exception case for the only string in exportData, which is the type of collisionRect (solid/liquid as 's'/'l', respectively). 
<a name="l145"><span class="ln">145  </span></a>            6. if the current type is a joint (when i == 1), make all values integers since they represent the points list indexes, since list indexes must be integers! 
<a name="l146"><span class="ln">146  </span></a>            7. if the current value isn't a number, it must be a list. as such, remove the brackets and convert the current value into a list. 
<a name="l147"><span class="ln">147  </span></a>                then convert all values in this list to a float. after that, assign the current value as a list to formattedData. 
<a name="l148"><span class="ln">148  </span></a>                here's what this would look like: '[0.1, 0.2, 0.3]' -&gt; '0.1, 0.2, 0.3' -&gt; [0.1, 0.2, 0.3] 
<a name="l149"><span class="ln">149  </span></a>            8. formattedData is now truly formatted data! simply add the points, joints, and collisionRects to their respective lists from the data in formattedData. 
<a name="l150"><span class="ln">150  </span></a>        &quot;&quot;&quot;</span>
<a name="l151"><span class="ln">151  </span></a>        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">)):</span>
<a name="l152"><span class="ln">152  </span></a>            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])):</span>
<a name="l153"><span class="ln">153  </span></a>                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">])):</span>
<a name="l154"><span class="ln">154  </span></a>                    <span class="s2">if </span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] != </span><span class="s4">'s'</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] != </span><span class="s4">'l'</span><span class="s3">):</span>
<a name="l155"><span class="ln">155  </span></a>                        <span class="s2">try</span><span class="s3">:</span>
<a name="l156"><span class="ln">156  </span></a>                            <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:  </span><span class="s0"># if current type is a joint</span>
<a name="l157"><span class="ln">157  </span></a>                                <span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">int</span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span>
<a name="l158"><span class="ln">158  </span></a>                                                                 <span class="s1">k</span><span class="s3">])  </span><span class="s0"># make data int since list indexes (of the points list) cannot be floats</span>
<a name="l159"><span class="ln">159  </span></a>                            <span class="s2">else</span><span class="s3">:</span>
<a name="l160"><span class="ln">160  </span></a>                                <span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">float</span><span class="s3">(</span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">])</span>
<a name="l161"><span class="ln">161  </span></a>                        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:  </span><span class="s0"># if current value is a list and not a number</span>
<a name="l162"><span class="ln">162  </span></a>                            <span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">].</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'['</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
<a name="l163"><span class="ln">163  </span></a>                            <span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">].</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">']'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
<a name="l164"><span class="ln">164  </span></a>                            <span class="s1">tempList </span><span class="s3">= </span><span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">].</span><span class="s1">split</span><span class="s3">(</span><span class="s4">', '</span><span class="s3">)  </span><span class="s0"># convert value into a list</span>
<a name="l165"><span class="ln">165  </span></a>                            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tempList</span><span class="s3">)):</span>
<a name="l166"><span class="ln">166  </span></a>                                <span class="s1">tempList</span><span class="s3">[</span><span class="s1">t</span><span class="s3">] = </span><span class="s1">float</span><span class="s3">(</span><span class="s1">tempList</span><span class="s3">[</span><span class="s1">t</span><span class="s3">])</span>
<a name="l167"><span class="ln">167  </span></a>                            <span class="s1">formattedData</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">j</span><span class="s3">][</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">tempList</span>
<a name="l168"><span class="ln">168  </span></a>        <span class="s1">points </span><span class="s3">= </span><span class="s1">formattedData</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]  </span><span class="s0"># format: [[cords (float)], radius (float), density (float)]</span>
<a name="l169"><span class="ln">169  </span></a>        <span class="s1">joints </span><span class="s3">= </span><span class="s1">formattedData</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># format: [point 1 index (float), point 2 index (float)]</span>
<a name="l170"><span class="ln">170  </span></a>        <span class="s1">collisionRects </span><span class="s3">= </span><span class="s1">formattedData</span><span class="s3">[</span>
<a name="l171"><span class="ln">171  </span></a>            <span class="s5">2</span><span class="s3">]  </span><span class="s0"># format: [[size (float)], [cords (float)], [angle (float)], density (float), viscosity (float), dragConst (float), transparency (float), rectType (string)]</span>
<a name="l172"><span class="ln">172  </span></a>        <span class="s0"># although dragConst is always 1, I plan to do something with this in the future</span>
<a name="l173"><span class="ln">173  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">points</span><span class="s3">:</span>
<a name="l174"><span class="ln">174  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">Point</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s5">2</span><span class="s3">], </span><span class="s2">True</span><span class="s3">))</span>
<a name="l175"><span class="ln">175  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">teleport</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])  </span><span class="s0"># move the point to its coordinates while maintaining 0 speed</span>
<a name="l176"><span class="ln">176  </span></a>        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">joints</span><span class="s3">:</span>
<a name="l177"><span class="ln">177  </span></a>            <span class="s0"># pass 'self' into Joint to allow it to get its initial length ('height')</span>
<a name="l178"><span class="ln">178  </span></a>            <span class="s0"># this is a must since importData is run in the Main class' initialization, so the game() instance doesn't exist at this moment in time!</span>
<a name="l179"><span class="ln">179  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">Joint</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'springConst'</span><span class="s3">], </span><span class="s1">j</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">j</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'damping'</span><span class="s3">], </span><span class="s5">69</span><span class="s3">, </span><span class="s1">self</span><span class="s3">))</span>
<a name="l180"><span class="ln">180  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__initCloths</span><span class="s3">(</span><span class="s1">j</span><span class="s3">)</span>
<a name="l181"><span class="ln">181  </span></a>        <span class="s2">for </span><span class="s1">cr </span><span class="s2">in </span><span class="s1">collisionRects</span><span class="s3">:</span>
<a name="l182"><span class="ln">182  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">CollisionRect</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">2</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">3</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">4</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">5</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">6</span><span class="s3">], </span><span class="s1">cr</span><span class="s3">[</span><span class="s5">7</span><span class="s3">]))</span>
<a name="l183"><span class="ln">183  </span></a>
<a name="l184"><span class="ln">184  </span></a>    <span class="s0"># identify cloths based on joints connected to a points</span>
<a name="l185"><span class="ln">185  </span></a>    <span class="s2">def </span><span class="s1">__initCloths</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">jDat</span><span class="s3">: </span><span class="s1">list</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l186"><span class="ln">186  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l187"><span class="ln">187  </span></a>        by looping through all points, if the index of both points match the point indexes of the joint (jDat), make both points have the same cloth. 
<a name="l188"><span class="ln">188  </span></a>        'p' and 'po' are indexes in the point list. 
<a name="l189"><span class="ln">189  </span></a>        the point at index 'p' will always be the one to have a cloth before any point at index 'po', so that its cloth value can spread to all other points in the same sprite. this logic is made possible by point 2 below. 
<a name="l190"><span class="ln">190  </span></a>        if statement analysis: 
<a name="l191"><span class="ln">191  </span></a>            1. 'po &gt; p': don't compare points that have already been looped through (e.g. [1, 5] and [5, 0] are unique, but [1, 5] and [5, 1] are not). also the current point won't ever be referring to itself. 
<a name="l192"><span class="ln">192  </span></a>                this reduces the time complexity of the nested for loop from O(n²) to O(n² / 2), since 'p' can never be larger than 'po'. 
<a name="l193"><span class="ln">193  </span></a>            2. '((jDat[0] == p) and (jDat[1] == po)) or ((jDat[1] == p) and (jDat[0] == po))': both point's indexes are equal to the point indexes of the joint, regardless of their order. 
<a name="l194"><span class="ln">194  </span></a>        &quot;&quot;&quot;</span>
<a name="l195"><span class="ln">195  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l196"><span class="ln">196  </span></a>            <span class="s2">for </span><span class="s1">po </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l197"><span class="ln">197  </span></a>                <span class="s2">if </span><span class="s3">(</span><span class="s1">po </span><span class="s3">&gt; </span><span class="s1">p</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(((</span><span class="s1">jDat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s1">p</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">jDat</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] == </span><span class="s1">po</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">((</span><span class="s1">jDat</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] == </span><span class="s1">p</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">jDat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s1">po</span><span class="s3">))):</span>
<a name="l198"><span class="ln">198  </span></a>                    <span class="s0"># if the point hasn't been assigned a cloth, make a new cloth with a unique key len(joints)</span>
<a name="l199"><span class="ln">199  </span></a>                    <span class="s0"># len(joints) will always be unique since a new joint is appended to the joints list each time this method runs</span>
<a name="l200"><span class="ln">200  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">== </span><span class="s4">''</span><span class="s3">:</span>
<a name="l201"><span class="ln">201  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">)</span><span class="s2">}</span><span class="s4">'</span>
<a name="l202"><span class="ln">202  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span>
<a name="l203"><span class="ln">203  </span></a>                        <span class="s1">p</span><span class="s3">].</span><span class="s1">cloth  </span><span class="s0"># make both point's cloths identical (since they are connected to the same joint)</span>
<a name="l204"><span class="ln">204  </span></a>
<a name="l205"><span class="ln">205  </span></a>    <span class="s0"># initialize all the lists that depend on the size of self.points and self.collisionRect</span>
<a name="l206"><span class="ln">206  </span></a>    <span class="s2">def </span><span class="s1">initLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l207"><span class="ln">207  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l208"><span class="ln">208  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">p</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'radius'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'density'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}, </span><span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'radius'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">,</span>
<a name="l209"><span class="ln">209  </span></a>                                                                                           <span class="s4">'density'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}}})  </span><span class="s0"># add a radius/density GUI to the GUI dictionary for each point, with the key as the integer value of the point's index</span>
<a name="l210"><span class="ln">210  </span></a>            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span>
<a name="l211"><span class="ln">211  </span></a>                    <span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">)):  </span><span class="s0"># append the below to each point for every collisionRect in the game</span>
<a name="l212"><span class="ln">212  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">collision</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
<a name="l213"><span class="ln">213  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">lastCollision</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
<a name="l214"><span class="ln">214  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">colliding</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l215"><span class="ln">215  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cubeCollision</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l216"><span class="ln">216  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cubeCollisionCalc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l217"><span class="ln">217  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cubeSubmersion</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l218"><span class="ln">218  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">incrementMultiplier</span><span class="s3">()</span>
<a name="l219"><span class="ln">219  </span></a>
<a name="l220"><span class="ln">220  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([])</span>
<a name="l221"><span class="ln">221  </span></a>            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l222"><span class="ln">222  </span></a>                <span class="s0"># this allows 'diff' to store the relative distance between every point to every other point where 'p' is the index of the reference point in question</span>
<a name="l223"><span class="ln">223  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
<a name="l224"><span class="ln">224  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">,</span>
<a name="l225"><span class="ln">225  </span></a>                        <span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">2</span><span class="s3">]  </span><span class="s0"># by default, set the last selected points to the latest points in 'self.points'</span>
<a name="l226"><span class="ln">226  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__updateCloths</span><span class="s3">()</span>
<a name="l227"><span class="ln">227  </span></a>        <span class="s0"># below is the code I used to get the relative size of the JetBrains font to the game scene</span>
<a name="l228"><span class="ln">228  </span></a>        <span class="s0"># myT = viz.addText3D('abcd', fontSize=1.69 / 4)  # OBSERVATION: font size of 1.69 has the width of 1 unit</span>
<a name="l229"><span class="ln">229  </span></a>        <span class="s0"># myT = viz.addText3D('a\nb\nc', fontSize=1)  # OBSERVATION: font size of 1 has the height of 1 unit</span>
<a name="l230"><span class="ln">230  </span></a>        <span class="s0"># myT.font(&quot;JetBrainsMono-2.304\\fonts\\ttf\\JetBrainsMono-Medium.ttf&quot;)</span>
<a name="l231"><span class="ln">231  </span></a>
<a name="l232"><span class="ln">232  </span></a>    <span class="s0"># update all the lists whenever a new point or collisionRect is added for the same reasons as the 'initLists' method</span>
<a name="l233"><span class="ln">233  </span></a>    <span class="s2">def </span><span class="s1">updateLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l234"><span class="ln">234  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">: {</span><span class="s4">'slider'</span><span class="s3">: {</span><span class="s4">'radius'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'density'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">},</span>
<a name="l235"><span class="ln">235  </span></a>                                                  <span class="s4">'manual'</span><span class="s3">: {</span><span class="s4">'radius'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, </span><span class="s4">'density'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}}})</span>
<a name="l236"><span class="ln">236  </span></a>        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">)):</span>
<a name="l237"><span class="ln">237  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">collision</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
<a name="l238"><span class="ln">238  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">lastCollision</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
<a name="l239"><span class="ln">239  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">colliding</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l240"><span class="ln">240  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cubeCollision</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l241"><span class="ln">241  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cubeCollisionCalc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l242"><span class="ln">242  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cubeSubmersion</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
<a name="l243"><span class="ln">243  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">incrementMultiplier</span><span class="s3">()</span>
<a name="l244"><span class="ln">244  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([])</span>
<a name="l245"><span class="ln">245  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">):</span>
<a name="l246"><span class="ln">246  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
<a name="l247"><span class="ln">247  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l248"><span class="ln">248  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
<a name="l249"><span class="ln">249  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__updateCloths</span><span class="s3">()</span>
<a name="l250"><span class="ln">250  </span></a>
<a name="l251"><span class="ln">251  </span></a>    <span class="s0"># put the indexes of all points into the clothData dictionary identify all points in a cloth</span>
<a name="l252"><span class="ln">252  </span></a>    <span class="s2">def </span><span class="s1">__updateCloths</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l253"><span class="ln">253  </span></a>        <span class="s2">global </span><span class="s1">clothNames  </span><span class="s0"># globalized to allow the clothNames dict in config.py to be updated for cloth/point selection in the GUISelector</span>
<a name="l254"><span class="ln">254  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l255"><span class="ln">255  </span></a>            <span class="s0"># if the point isn't a part of a cloth, make its key as its position index 'p' in the points list</span>
<a name="l256"><span class="ln">256  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">== </span><span class="s4">''</span><span class="s3">:</span>
<a name="l257"><span class="ln">257  </span></a>                <span class="s1">clothNames</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">p</span><span class="s2">}</span><span class="s4">'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">})</span>
<a name="l258"><span class="ln">258  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">p</span><span class="s2">}</span><span class="s4">'</span><span class="s3">: [</span><span class="s1">p</span><span class="s3">]})</span>
<a name="l259"><span class="ln">259  </span></a>            <span class="s0"># if the current point's cloth does not currently exist in clothData AND the current point is a part of a cloth, then add the cloth's name as a key to clothData and clothNames</span>
<a name="l260"><span class="ln">260  </span></a>            <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">:</span>
<a name="l261"><span class="ln">261  </span></a>                <span class="s1">clothNames</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth</span><span class="s3">: </span><span class="s2">None</span><span class="s3">})</span>
<a name="l262"><span class="ln">262  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth</span><span class="s3">: []})</span>
<a name="l263"><span class="ln">263  </span></a>            <span class="s0"># if the current point is a part of a cloth AND the current point's index doesn't currently exist in clothData, add it to clothData</span>
<a name="l264"><span class="ln">264  </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s2">not </span><span class="s1">checkInList</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth</span><span class="s3">], </span><span class="s1">p</span><span class="s3">)):</span>
<a name="l265"><span class="ln">265  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
<a name="l266"><span class="ln">266  </span></a>
<a name="l267"><span class="ln">267  </span></a>    <span class="s0"># used to import tutorials from 'tutorialTexts.txt'</span>
<a name="l268"><span class="ln">268  </span></a>    <span class="s2">def </span><span class="s1">__importTutorials</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l269"><span class="ln">269  </span></a>        <span class="s1">f </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s4">'tutorialTexts'</span><span class="s3">, </span><span class="s4">'r'</span><span class="s3">)</span>
<a name="l270"><span class="ln">270  </span></a>        <span class="s1">tutors </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">read</span><span class="s3">().</span><span class="s1">splitlines</span><span class="s3">()</span>
<a name="l271"><span class="ln">271  </span></a>        <span class="s1">tNames </span><span class="s3">= []</span>
<a name="l272"><span class="ln">272  </span></a>        <span class="s1">tTexts </span><span class="s3">= []</span>
<a name="l273"><span class="ln">273  </span></a>        <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">tutors</span><span class="s3">:</span>
<a name="l274"><span class="ln">274  </span></a>            <span class="s2">if </span><span class="s1">l</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s4">'---'</span><span class="s3">) != -</span><span class="s5">1</span><span class="s3">:</span>
<a name="l275"><span class="ln">275  </span></a>                <span class="s1">tTexts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([])</span>
<a name="l276"><span class="ln">276  </span></a>                <span class="s1">tempList </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">l</span><span class="s3">)</span>
<a name="l277"><span class="ln">277  </span></a>                <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l278"><span class="ln">278  </span></a>                    <span class="s1">tempList</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)  </span><span class="s0"># gets rid of the triple-dash to add the title to tNames</span>
<a name="l279"><span class="ln">279  </span></a>                <span class="s1">tempStr </span><span class="s3">= </span><span class="s4">''</span>
<a name="l280"><span class="ln">280  </span></a>                <span class="s2">for </span><span class="s1">tutorial </span><span class="s2">in </span><span class="s1">tempList</span><span class="s3">:</span>
<a name="l281"><span class="ln">281  </span></a>                    <span class="s1">tempStr </span><span class="s3">= </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">tempStr</span><span class="s2">}{</span><span class="s1">tutorial</span><span class="s2">}</span><span class="s4">'</span>
<a name="l282"><span class="ln">282  </span></a>                <span class="s1">tNames</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tempStr</span><span class="s3">)</span>
<a name="l283"><span class="ln">283  </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l284"><span class="ln">284  </span></a>                <span class="s1">tTexts</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span>
<a name="l285"><span class="ln">285  </span></a>                    <span class="s1">l</span><span class="s3">)  </span><span class="s0"># if the current line isn't a tutorial's title, add it to the latest tutorial's contents</span>
<a name="l286"><span class="ln">286  </span></a>        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tNames</span><span class="s3">)):</span>
<a name="l287"><span class="ln">287  </span></a>            <span class="s1">tNames</span><span class="s3">[</span><span class="s1">t</span><span class="s3">] = </span><span class="s1">tNames</span><span class="s3">[</span><span class="s1">t</span><span class="s3">].</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'newLine'</span><span class="s3">,</span>
<a name="l288"><span class="ln">288  </span></a>                                          <span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)  </span><span class="s0"># solution from Python Discord, credit goes to lordtyrionlannister &quot;Saul Goodman&quot;. replaces all newLine values with an actual new line in string format.</span>
<a name="l289"><span class="ln">289  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__tutorialTexts</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">tNames</span><span class="s3">[</span><span class="s1">t</span><span class="s3">]: </span><span class="s1">tTexts</span><span class="s3">[</span><span class="s1">t</span><span class="s3">]})  </span><span class="s0"># update local information about the tutorial</span>
<a name="l290"><span class="ln">290  </span></a>            <span class="s1">tutorialNames</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s1">tNames</span><span class="s3">[</span><span class="s1">t</span><span class="s3">]: </span><span class="s2">None</span><span class="s3">})  </span><span class="s0"># update the global value of tutorialNames for use in GUISelector</span>
<a name="l291"><span class="ln">291  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s4">'Tutorials'</span><span class="s3">][</span><span class="s4">''</span><span class="s3">].</span><span class="s1">update</span><span class="s3">({</span><span class="s1">tNames</span><span class="s3">[</span><span class="s1">t</span><span class="s3">]: </span><span class="s2">None</span><span class="s3">})  </span><span class="s0"># update local values of tutorials in self.GUI</span>
<a name="l292"><span class="ln">292  </span></a>        <span class="s1">f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
<a name="l293"><span class="ln">293  </span></a>        <span class="s2">if not </span><span class="s1">imports</span><span class="s3">:</span>
<a name="l294"><span class="ln">294  </span></a>            <span class="s0"># always summon the introduction tutorial when the program starts</span>
<a name="l295"><span class="ln">295  </span></a>            <span class="s0"># this won't be summoned if the user is importing from exportData since they would have already seen the introduction tutorial in spriteCreator.py</span>
<a name="l296"><span class="ln">296  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s4">'Tutorials'</span><span class="s3">][</span><span class="s4">''</span><span class="s3">][</span><span class="s4">'Introduction'</span><span class="s3">] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Tutorial</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">], [</span><span class="s5">10</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">],</span>
<a name="l297"><span class="ln">297  </span></a>                                                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">__tutorialTexts</span><span class="s3">[</span><span class="s4">'Introduction'</span><span class="s3">], [], </span><span class="s5">0.3</span><span class="s3">,</span>
<a name="l298"><span class="ln">298  </span></a>                                                                         <span class="s1">lControllerObj</span><span class="s3">, </span><span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l299"><span class="ln">299  </span></a>
<a name="l300"><span class="ln">300  </span></a>    <span class="s0"># teleport a cloth, or a point that's part of a cloth, to a hand's position</span>
<a name="l301"><span class="ln">301  </span></a>    <span class="s2">def </span><span class="s1">__tpCloth</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cloth</span><span class="s3">: (</span><span class="s1">int </span><span class="s2">or </span><span class="s1">str</span><span class="s3">), </span><span class="s1">cords</span><span class="s3">: </span><span class="s1">list</span><span class="s3">, </span><span class="s1">cIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l302"><span class="ln">302  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l303"><span class="ln">303  </span></a>        :param cloth: the name of a cloth/a point's index, depending on 'cloth' being a string/integer, respectively. 
<a name="l304"><span class="ln">304  </span></a>        :param cords: location to teleport the cloth/point to. 
<a name="l305"><span class="ln">305  </span></a>        :param cIdx: index of the controller to teleport the point/cloth to. 
<a name="l306"><span class="ln">306  </span></a> 
<a name="l307"><span class="ln">307  </span></a>        when teleporting a point that's part of a cloth, the entire cloth (all points in the cloth) should be teleported at once. 
<a name="l308"><span class="ln">308  </span></a>        this prevents its joints from being stretched too far which would cause the user to lose control of the cloth. 
<a name="l309"><span class="ln">309  </span></a>        this is done by getting the change in position of the reference point during its teleport, and then adding this change in position to all position values of the other points in the cloth. 
<a name="l310"><span class="ln">310  </span></a>            the logic is as follows: 'cords' - 'oldCords', where 'cords' is the destination and 'oldCords' is the initial position. 
<a name="l311"><span class="ln">311  </span></a>        although this only applies if the reference point is a part of a cloth, this method works even if the reference point isn't a part of a cloth. 
<a name="l312"><span class="ln">312  </span></a>        check out this link for an illustration: https://drive.google.com/file/d/1d5MI1ox6PDqQiyb2x0-5k5LS-S4PIIEs/view?usp=drive_link/ 
<a name="l313"><span class="ln">313  </span></a>        &quot;&quot;&quot;</span>
<a name="l314"><span class="ln">314  </span></a>        <span class="s1">cordDiff </span><span class="s3">= []  </span><span class="s0"># stores the change in pos of the reference point</span>
<a name="l315"><span class="ln">315  </span></a>        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">cloth</span><span class="s3">) </span><span class="s2">is </span><span class="s1">int</span><span class="s3">:  </span><span class="s0"># if 'cloth' is a point index</span>
<a name="l316"><span class="ln">316  </span></a>            <span class="s1">pIdx </span><span class="s3">= </span><span class="s1">cloth</span>
<a name="l317"><span class="ln">317  </span></a>            <span class="s1">cloth </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">pIdx</span><span class="s3">].</span><span class="s1">cloth</span>
<a name="l318"><span class="ln">318  </span></a>        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># if 'cloth' is the name of a cloth</span>
<a name="l319"><span class="ln">319  </span></a>            <span class="s1">pIdx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">[</span><span class="s1">cloth</span><span class="s3">][-</span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># set the reference point's index to the latest point in the cloth</span>
<a name="l320"><span class="ln">320  </span></a>
<a name="l321"><span class="ln">321  </span></a>        <span class="s0"># get change in pos as a result of the reference point's teleportation</span>
<a name="l322"><span class="ln">322  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">pIdx</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">cIdx</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l323"><span class="ln">323  </span></a>        <span class="s2">for </span><span class="s1">co </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l324"><span class="ln">324  </span></a>            <span class="s1">cordDiff</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">pIdx</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">co</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">pIdx</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s1">co</span><span class="s3">])</span>
<a name="l325"><span class="ln">325  </span></a>
<a name="l326"><span class="ln">326  </span></a>        <span class="s2">if </span><span class="s1">cloth </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">:  </span><span class="s0"># only teleport other points if the reference point is a part of a cloth</span>
<a name="l327"><span class="ln">327  </span></a>            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__clothData</span><span class="s3">[</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">cloth</span><span class="s2">}</span><span class="s4">'</span><span class="s3">]:</span>
<a name="l328"><span class="ln">328  </span></a>                <span class="s2">if </span><span class="s1">p </span><span class="s3">!= </span><span class="s1">pIdx</span><span class="s3">:  </span><span class="s0"># exclude the reference point from teleportation since the reference point is teleported even if the value of 'cloth' is empty</span>
<a name="l329"><span class="ln">329  </span></a>                    <span class="s2">for </span><span class="s1">cor </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l330"><span class="ln">330  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">cor</span><span class="s3">] += </span><span class="s1">cordDiff</span><span class="s3">[</span><span class="s1">cor</span><span class="s3">]</span>
<a name="l331"><span class="ln">331  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s1">cor</span><span class="s3">] += </span><span class="s1">cordDiff</span><span class="s3">[</span><span class="s1">cor</span><span class="s3">]</span>
<a name="l332"><span class="ln">332  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">pIdx</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l333"><span class="ln">333  </span></a>
<a name="l334"><span class="ln">334  </span></a>    <span class="s0"># the method in this class that allows the program to run and manages all other methods to calculate physics of each point and joint</span>
<a name="l335"><span class="ln">335  </span></a>    <span class="s2">def </span><span class="s1">main</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l336"><span class="ln">336  </span></a>        <span class="s2">global </span><span class="s1">physicsTime  </span><span class="s0"># must be globalised since gameSpeed can be changed by the user from the GUI selector</span>
<a name="l337"><span class="ln">337  </span></a>        <span class="s1">physicsTime </span><span class="s3">= </span><span class="s1">calcRate </span><span class="s3">* (</span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">globalVars</span><span class="s3">[</span>
<a name="l338"><span class="ln">338  </span></a>            <span class="s4">'gameSpeed'</span><span class="s3">])  </span><span class="s0"># update the value of physicsTime based on gameSpeed, since gameSpeed can be changed in a GUI</span>
<a name="l339"><span class="ln">339  </span></a>        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllerAmt</span><span class="s3">):</span>
<a name="l340"><span class="ln">340  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__getButtonReleased</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>
<a name="l341"><span class="ln">341  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__pauseGame</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>
<a name="l342"><span class="ln">342  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__summonGUISelector</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>
<a name="l343"><span class="ln">343  </span></a>
<a name="l344"><span class="ln">344  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__dragPoint</span><span class="s3">()</span>
<a name="l345"><span class="ln">345  </span></a>
<a name="l346"><span class="ln">346  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l347"><span class="ln">347  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">sf </span><span class="s3">= </span><span class="s1">globalVars</span><span class="s3">[</span>
<a name="l348"><span class="ln">348  </span></a>                <span class="s4">'friction'</span><span class="s3">]  </span><span class="s0"># update each point's local value of friction based on globalVars['friction'], since friction can be changed in a GUI</span>
<a name="l349"><span class="ln">349  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__pointCollision</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
<a name="l350"><span class="ln">350  </span></a>
<a name="l351"><span class="ln">351  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">move</span><span class="s3">()</span>
<a name="l352"><span class="ln">352  </span></a>
<a name="l353"><span class="ln">353  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__getDist</span><span class="s3">()  </span><span class="s0"># cache the distance between each point</span>
<a name="l354"><span class="ln">354  </span></a>
<a name="l355"><span class="ln">355  </span></a>        <span class="s0"># update each joint</span>
<a name="l356"><span class="ln">356  </span></a>        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">)):</span>
<a name="l357"><span class="ln">357  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">stiffness </span><span class="s3">= </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'springConst'</span><span class="s3">]  </span><span class="s0"># set stiffness for the same reason as physicsTime</span>
<a name="l358"><span class="ln">358  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">dampingConst </span><span class="s3">= </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'damping'</span><span class="s3">]  </span><span class="s0"># set dampingConst for the same reason as physicsTime</span>
<a name="l359"><span class="ln">359  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">maxStrain </span><span class="s3">= </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'strain'</span><span class="s3">]  </span><span class="s0"># set strain for the same reason as physicsTime</span>
<a name="l360"><span class="ln">360  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">update</span><span class="s3">()</span>
<a name="l361"><span class="ln">361  </span></a>            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pause</span><span class="s3">:</span>
<a name="l362"><span class="ln">362  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">constrain</span><span class="s3">()  </span><span class="s0"># apply a force to each point from each joint</span>
<a name="l363"><span class="ln">363  </span></a>
<a name="l364"><span class="ln">364  </span></a>    <span class="s2">def </span><span class="s1">__pointCollision</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l365"><span class="ln">365  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l366"><span class="ln">366  </span></a>        :param p: index position of the reference point to check for collisions with. 
<a name="l367"><span class="ln">367  </span></a> 
<a name="l368"><span class="ln">368  </span></a>        this method is used to detect and resolve the collisions between two points. 
<a name="l369"><span class="ln">369  </span></a>        currently, it only works with 100% elasticity since I can't figure out what this means: https://en.wikipedia.org/wiki/Collision_response#Impulse-based_reaction_model 
<a name="l370"><span class="ln">370  </span></a> 
<a name="l371"><span class="ln">371  </span></a>        process: 
<a name="l372"><span class="ln">372  </span></a>            1. loop through all points. 
<a name="l373"><span class="ln">373  </span></a>                'po &gt; p': don't compare points that have already been looped through (e.g. [1, 5] and [5, 0] are unique, but [1, 5] and [5, 1] are not). 
<a name="l374"><span class="ln">374  </span></a>                this reduces the time complexity of the nested for loop from O(n²) to O(n² / 2), since 'p' can never be larger than 'po'. 
<a name="l375"><span class="ln">375  </span></a>            2. if the distance between both points &lt;= the sum of their radii, there's a collision between them. 
<a name="l376"><span class="ln">376  </span></a>                check out this link for logical proof: https://drive.google.com/file/d/1WH5wvc5lVaKQhG9lBSByJf3SIlzh-unJ/view?usp=drive_link 
<a name="l377"><span class="ln">377  </span></a>            3. calculate the size of the collision normal's angles. 
<a name="l378"><span class="ln">378  </span></a>                imagine a line connecting the centres of both points. that's the collision normal! 
<a name="l379"><span class="ln">379  </span></a>            4. calculate the size of relative components of velocity for each point. 
<a name="l380"><span class="ln">380  </span></a>                then, using spherical coordinate geometry, calculate the resultant speed of these velocities relative to the normal. 
<a name="l381"><span class="ln">381  </span></a>                imagine yourself standing on the point of collision on either point. how fast you see the other point moving towards you (as you get crushed between them) is what this value represents! 
<a name="l382"><span class="ln">382  </span></a>            5. use the formula: &quot;ΔP = ((m1 * m2 * (v1 - v2) * normal) / (m1 + m2)) * 2&quot; to get the change in momentum of both points. 
<a name="l383"><span class="ln">383  </span></a>                I derived this formula by testing collisions in this PhET simulation: https://phet.colorado.edu/sims/html/collision-lab/latest/collision-lab_all.html 
<a name="l384"><span class="ln">384  </span></a>            6. get the resultant direction of motion for each point depending on which quartile they're colliding in. 
<a name="l385"><span class="ln">385  </span></a>                check out this link for the logic behind this: https://drive.google.com/file/d/1GDe4hnh2pb6aZ9L_Rz93G3oayglutxei/view?usp=sharing 
<a name="l386"><span class="ln">386  </span></a>            7. resolve the collision using spherical coordinate geometry, reversing the direction of movement for both points due to Newton's 3rd Law. 
<a name="l387"><span class="ln">387  </span></a>        &quot;&quot;&quot;</span>
<a name="l388"><span class="ln">388  </span></a>        <span class="s0"># detect &amp; resolve collisions with all points</span>
<a name="l389"><span class="ln">389  </span></a>        <span class="s2">for </span><span class="s1">po </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l390"><span class="ln">390  </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">po </span><span class="s3">&gt; </span><span class="s1">p</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">disabledPointCollisions</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">po</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l391"><span class="ln">391  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">disabledPointCollisions</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">p</span><span class="s3">):</span>
<a name="l392"><span class="ln">392  </span></a>                <span class="s0"># detect for point&lt;&gt;point collisions, utilizing the cached values of dist</span>
<a name="l393"><span class="ln">393  </span></a>                <span class="s1">sumR </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">radius </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">radius  </span><span class="s0"># alias for summing radii of both points</span>
<a name="l394"><span class="ln">394  </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s1">po</span><span class="s3">] &lt;= </span><span class="s1">sumR</span><span class="s3">:</span>
<a name="l395"><span class="ln">395  </span></a>                    <span class="s1">mOne </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">mass</span><span class="s3">)</span>
<a name="l396"><span class="ln">396  </span></a>                    <span class="s1">mTwo </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">mass</span><span class="s3">)</span>
<a name="l397"><span class="ln">397  </span></a>                    <span class="s1">vOne </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">velocity</span><span class="s3">)</span>
<a name="l398"><span class="ln">398  </span></a>                    <span class="s1">vTwo </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">velocity</span><span class="s3">)</span>
<a name="l399"><span class="ln">399  </span></a>                    <span class="s1">normal </span><span class="s3">= </span><span class="s1">getAbsThreeDAngle</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">,</span>
<a name="l400"><span class="ln">400  </span></a>                                               <span class="s4">'y'</span><span class="s3">)  </span><span class="s0"># get the size of the collision normal's angle</span>
<a name="l401"><span class="ln">401  </span></a>                    <span class="s1">vRel </span><span class="s3">= [</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">vOne</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">vTwo</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">vOne</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">vTwo</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">vOne</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] - </span><span class="s1">vTwo</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])]</span>
<a name="l402"><span class="ln">402  </span></a>                    <span class="s1">resultS </span><span class="s3">= (</span><span class="s1">vRel</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])) + (</span><span class="s1">vRel</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])) + (</span>
<a name="l403"><span class="ln">403  </span></a>                    <span class="s1">vRel</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">cos</span><span class="s3">(</span>
<a name="l404"><span class="ln">404  </span></a>                        <span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])  </span><span class="s0"># calculate resultant speed of each point relative to the normal</span>
<a name="l405"><span class="ln">405  </span></a>                    <span class="s1">deltaP </span><span class="s3">= ((</span><span class="s1">mOne </span><span class="s3">* </span><span class="s1">mTwo</span><span class="s3">) / (</span>
<a name="l406"><span class="ln">406  </span></a>                                <span class="s1">mOne </span><span class="s3">+ </span><span class="s1">mTwo</span><span class="s3">)) * </span><span class="s1">resultS </span><span class="s3">* </span><span class="s5">2  </span><span class="s0"># calculate change in momentum of both points</span>
<a name="l407"><span class="ln">407  </span></a>
<a name="l408"><span class="ln">408  </span></a>                    <span class="s0"># determine the direction at which each point should be deflected</span>
<a name="l409"><span class="ln">409  </span></a>                    <span class="s1">multiplier </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l410"><span class="ln">410  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
<a name="l411"><span class="ln">411  </span></a>                        <span class="s1">multiplier</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = -</span><span class="s5">1</span>
<a name="l412"><span class="ln">412  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:</span>
<a name="l413"><span class="ln">413  </span></a>                        <span class="s1">multiplier</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = -</span><span class="s5">1</span>
<a name="l414"><span class="ln">414  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]:</span>
<a name="l415"><span class="ln">415  </span></a>                        <span class="s1">multiplier</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = -</span><span class="s5">1</span>
<a name="l416"><span class="ln">416  </span></a>
<a name="l417"><span class="ln">417  </span></a>                    <span class="s0"># calculate resultant velocity of each point and resolve the collision</span>
<a name="l418"><span class="ln">418  </span></a>                    <span class="s0"># changing cords will change velocity due to Verlet integration</span>
<a name="l419"><span class="ln">419  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s1">deltaP </span><span class="s3">* </span><span class="s1">multiplier</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) / (</span>
<a name="l420"><span class="ln">420  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">calcRate</span><span class="s3">)</span>
<a name="l421"><span class="ln">421  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s1">deltaP </span><span class="s3">* </span><span class="s1">multiplier</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) / (</span>
<a name="l422"><span class="ln">422  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">calcRate</span><span class="s3">)</span>
<a name="l423"><span class="ln">423  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] -= </span><span class="s1">deltaP </span><span class="s3">* </span><span class="s1">multiplier</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) / (</span>
<a name="l424"><span class="ln">424  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">calcRate</span><span class="s3">)</span>
<a name="l425"><span class="ln">425  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s1">deltaP </span><span class="s3">* </span><span class="s1">multiplier</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) / (</span>
<a name="l426"><span class="ln">426  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">calcRate</span><span class="s3">)</span>
<a name="l427"><span class="ln">427  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] -= </span><span class="s1">deltaP </span><span class="s3">* </span><span class="s1">multiplier</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) / (</span>
<a name="l428"><span class="ln">428  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">calcRate</span><span class="s3">)</span>
<a name="l429"><span class="ln">429  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] += </span><span class="s1">deltaP </span><span class="s3">* </span><span class="s1">multiplier</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">normal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) / (</span>
<a name="l430"><span class="ln">430  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">calcRate</span><span class="s3">)</span>
<a name="l431"><span class="ln">431  </span></a>
<a name="l432"><span class="ln">432  </span></a>    <span class="s0"># get if a button isn't being pressed to allow for single-click detection</span>
<a name="l433"><span class="ln">433  </span></a>    <span class="s2">def </span><span class="s1">__getButtonReleased</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l434"><span class="ln">434  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l435"><span class="ln">435  </span></a>        :param cIdx: controller index value 
<a name="l436"><span class="ln">436  </span></a>        &quot;&quot;&quot;</span>
<a name="l437"><span class="ln">437  </span></a>        <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">:</span>
<a name="l438"><span class="ln">438  </span></a>            <span class="s2">if not </span><span class="s1">buttonPressed</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s1">cIdx</span><span class="s3">], </span><span class="s1">cIdx</span><span class="s3">):</span>
<a name="l439"><span class="ln">439  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s1">b</span><span class="s3">][</span><span class="s1">cIdx</span><span class="s3">] = </span><span class="s2">False</span>
<a name="l440"><span class="ln">440  </span></a>
<a name="l441"><span class="ln">441  </span></a>    <span class="s0"># summon the GUI selector if the 'GUISelector' button is pressed</span>
<a name="l442"><span class="ln">442  </span></a>    <span class="s2">def </span><span class="s1">__summonGUISelector</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l443"><span class="ln">443  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l444"><span class="ln">444  </span></a>        :param cIdx: controller index value 
<a name="l445"><span class="ln">445  </span></a>        &quot;&quot;&quot;</span>
<a name="l446"><span class="ln">446  </span></a>        <span class="s0"># only summon if the GUISelector button isn't being held down</span>
<a name="l447"><span class="ln">447  </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'GUISelector'</span><span class="s3">][</span><span class="s1">cIdx</span><span class="s3">]) </span><span class="s2">and </span><span class="s1">buttonPressed</span><span class="s3">(</span><span class="s4">'GUISelector'</span><span class="s3">, </span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s1">cIdx</span><span class="s3">],</span>
<a name="l448"><span class="ln">448  </span></a>                                                                          <span class="s1">cIdx</span><span class="s3">):</span>
<a name="l449"><span class="ln">449  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'GUISelector'</span><span class="s3">][</span><span class="s1">cIdx</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l450"><span class="ln">450  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s4">'GUISelector'</span><span class="s3">][</span><span class="s4">''</span><span class="s3">][</span><span class="s4">''</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
<a name="l451"><span class="ln">451  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s4">'GUISelector'</span><span class="s3">][</span><span class="s4">''</span><span class="s3">][</span><span class="s4">''</span><span class="s3">] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">GUISelector</span><span class="s3">(</span><span class="s1">globalVars</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">cIdx</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">,</span>
<a name="l452"><span class="ln">452  </span></a>                                                                      <span class="s1">lControllerObj</span><span class="s3">, </span><span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l453"><span class="ln">453  </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l454"><span class="ln">454  </span></a>                <span class="s1">removeGUI</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s4">'GUISelector'</span><span class="s3">][</span><span class="s4">''</span><span class="s3">][</span><span class="s4">''</span><span class="s3">])</span>
<a name="l455"><span class="ln">455  </span></a>
<a name="l456"><span class="ln">456  </span></a>    <span class="s0"># pause all point and joint physics if the 'pause' button is pressed</span>
<a name="l457"><span class="ln">457  </span></a>    <span class="s2">def </span><span class="s1">__pauseGame</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l458"><span class="ln">458  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l459"><span class="ln">459  </span></a>        :param cIdx: controller index value 
<a name="l460"><span class="ln">460  </span></a>        &quot;&quot;&quot;</span>
<a name="l461"><span class="ln">461  </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'pause'</span><span class="s3">][</span><span class="s1">cIdx</span><span class="s3">]) </span><span class="s2">and </span><span class="s1">buttonPressed</span><span class="s3">(</span><span class="s4">'pause'</span><span class="s3">, </span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s1">cIdx</span><span class="s3">], </span><span class="s1">cIdx</span><span class="s3">):</span>
<a name="l462"><span class="ln">462  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'pause'</span><span class="s3">][</span><span class="s1">cIdx</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l463"><span class="ln">463  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">pause </span><span class="s3">= </span><span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pause  </span><span class="s0"># reciprocate between True and False</span>
<a name="l464"><span class="ln">464  </span></a>
<a name="l465"><span class="ln">465  </span></a>    <span class="s2">def </span><span class="s1">render</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l466"><span class="ln">466  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__updateGUI</span><span class="s3">()  </span><span class="s0"># update all GUIs and their variables</span>
<a name="l467"><span class="ln">467  </span></a>        <span class="s1">controls</span><span class="s3">.</span><span class="s1">main</span><span class="s3">()  </span><span class="s0"># runs the main function in the current control (keyboard/VR) setting</span>
<a name="l468"><span class="ln">468  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">:</span>
<a name="l469"><span class="ln">469  </span></a>            <span class="s1">p</span><span class="s3">.</span><span class="s1">draw</span><span class="s3">()</span>
<a name="l470"><span class="ln">470  </span></a>        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">:</span>
<a name="l471"><span class="ln">471  </span></a>            <span class="s1">j</span><span class="s3">.</span><span class="s1">draw</span><span class="s3">()</span>
<a name="l472"><span class="ln">472  </span></a>        <span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">:</span>
<a name="l473"><span class="ln">473  </span></a>            <span class="s2">for </span><span class="s1">gu </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">g</span><span class="s3">]:</span>
<a name="l474"><span class="ln">474  </span></a>                <span class="s2">for </span><span class="s1">gui </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">g</span><span class="s3">][</span><span class="s1">gu</span><span class="s3">]:</span>
<a name="l475"><span class="ln">475  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">g</span><span class="s3">][</span><span class="s1">gu</span><span class="s3">][</span><span class="s1">gui</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l476"><span class="ln">476  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">g</span><span class="s3">][</span><span class="s1">gu</span><span class="s3">][</span><span class="s1">gui</span><span class="s3">].</span><span class="s1">draw</span><span class="s3">(</span><span class="s1">controls</span><span class="s3">.</span><span class="s1">camCords</span><span class="s3">)</span>
<a name="l477"><span class="ln">477  </span></a>
<a name="l478"><span class="ln">478  </span></a>    <span class="s0"># used to drag a point around using a hand, as well as running the animations for doing so</span>
<a name="l479"><span class="ln">479  </span></a>    <span class="s2">def </span><span class="s1">__dragPoint</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l480"><span class="ln">480  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l481"><span class="ln">481  </span></a>        process: 
<a name="l482"><span class="ln">482  </span></a>            1. loop through all controllers. 
<a name="l483"><span class="ln">483  </span></a>            2. detect for GUI interactions with the current hand. 
<a name="l484"><span class="ln">484  </span></a>            3. loop through all points; detect for collisions between points and the current hand. if there's a collision: 
<a name="l485"><span class="ln">485  </span></a>                a) start the collision animation (collP) 
<a name="l486"><span class="ln">486  </span></a>                b) detect for selection 
<a name="l487"><span class="ln">487  </span></a>            4. if a point is being selected by a hand, get its relative position to the hand to freeze its position relative to the hand. (see step 8) 
<a name="l488"><span class="ln">488  </span></a>            5. detect for double clicks. if the current hand's select button is pressed twice within 0.25s, allow the selected point's radius &amp; density to be modified. 
<a name="l489"><span class="ln">489  </span></a>            6. set the selecting point to be dragged until &quot;select&quot; is released. 
<a name="l490"><span class="ln">490  </span></a>                this allows the controller to drag the point along with it even if they are no longer colliding (which can happen in-between frames). 
<a name="l491"><span class="ln">491  </span></a>            7. set the last selected point (lastP) to the currently selected point for the current hand to allow for the hand to recall said point. (see step 11) 
<a name="l492"><span class="ln">492  </span></a>            see below for point 8 onwards. 
<a name="l493"><span class="ln">493  </span></a>        &quot;&quot;&quot;</span>
<a name="l494"><span class="ln">494  </span></a>        <span class="s0"># if mode == 'vr':</span>
<a name="l495"><span class="ln">495  </span></a>        <span class="s0">#     print(controlsConf.controllers[0].getButtonState() % touchpad, controlsConf.controllers[1].getButtonState() % touchpad)  # prints the current button being pressed for each controller</span>
<a name="l496"><span class="ln">496  </span></a>
<a name="l497"><span class="ln">497  </span></a>        <span class="s0"># loop through all drag code for each controller</span>
<a name="l498"><span class="ln">498  </span></a>        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllerAmt</span><span class="s3">):</span>
<a name="l499"><span class="ln">499  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__clickTime</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] &lt;= </span><span class="s5">0.25</span><span class="s3">:</span>
<a name="l500"><span class="ln">500  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__clickTime</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] += </span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">calcRate  </span><span class="s0"># increase time since the last click</span>
<a name="l501"><span class="ln">501  </span></a>            <span class="s2">for </span><span class="s1">gVar </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">:</span>
<a name="l502"><span class="ln">502  </span></a>                <span class="s2">for </span><span class="s1">gType </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">]:</span>
<a name="l503"><span class="ln">503  </span></a>                    <span class="s2">for </span><span class="s1">gAxis </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">][</span><span class="s1">gType</span><span class="s3">]:</span>
<a name="l504"><span class="ln">504  </span></a>                        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">][</span><span class="s1">gType</span><span class="s3">][</span><span class="s1">gAxis</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l505"><span class="ln">505  </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">][</span><span class="s1">gType</span><span class="s3">][</span><span class="s1">gAxis</span><span class="s3">].</span><span class="s1">drag</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">selectP</span><span class="s3">(</span><span class="s1">c</span><span class="s3">))  </span><span class="s0"># detect GUI interactions</span>
<a name="l506"><span class="ln">506  </span></a>            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l507"><span class="ln">507  </span></a>                <span class="s2">if </span><span class="s1">detectPointCollision</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">,</span>
<a name="l508"><span class="ln">508  </span></a>                                        <span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">):  </span><span class="s0"># any point&lt;&gt;hand collision</span>
<a name="l509"><span class="ln">509  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">p</span>
<a name="l510"><span class="ln">510  </span></a>                    <span class="s2">if </span><span class="s1">selectP</span><span class="s3">(</span><span class="s1">c</span><span class="s3">):</span>
<a name="l511"><span class="ln">511  </span></a>                        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'select'</span><span class="s3">][</span>
<a name="l512"><span class="ln">512  </span></a>                            <span class="s1">c</span><span class="s3">]:  </span><span class="s0"># prevents other points from being picked up while a current point is being selected</span>
<a name="l513"><span class="ln">513  </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'select'</span><span class="s3">][</span><span class="s1">c</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l514"><span class="ln">514  </span></a>                            <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l515"><span class="ln">515  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__relPos</span><span class="s3">[</span><span class="s1">c</span><span class="s3">][</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] - </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
<a name="l516"><span class="ln">516  </span></a>                            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__clickTime</span><span class="s3">[</span>
<a name="l517"><span class="ln">517  </span></a>                                <span class="s1">c</span><span class="s3">] &lt; </span><span class="s5">0.25</span><span class="s3">:  </span><span class="s0"># if there's a double click, summon sliders (if in VR) or manual inputs (if in keyboard/mouse) to change the density and radius of the double-clicked point</span>
<a name="l518"><span class="ln">518  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__setRadiusDensityGUI</span><span class="s3">(</span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
<a name="l519"><span class="ln">519  </span></a>                            <span class="s2">else</span><span class="s3">:</span>
<a name="l520"><span class="ln">520  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__clickTime</span><span class="s3">[</span>
<a name="l521"><span class="ln">521  </span></a>                                    <span class="s1">c</span><span class="s3">] = </span><span class="s5">0  </span><span class="s0"># reset the time since last click, since this click IS the last click!</span>
<a name="l522"><span class="ln">522  </span></a>                        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:  </span><span class="s0"># used to set the drag variables if they are not already set</span>
<a name="l523"><span class="ln">523  </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">p</span>
<a name="l524"><span class="ln">524  </span></a>                            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] != </span><span class="s1">p</span><span class="s3">:  </span><span class="s0"># no need to run the below if the value of lastP won't change</span>
<a name="l525"><span class="ln">525  </span></a>                                <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'vr'</span><span class="s3">:</span>
<a name="l526"><span class="ln">526  </span></a>                                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span>
<a name="l527"><span class="ln">527  </span></a>                                        <span class="s1">c </span><span class="s3">- </span><span class="s5">1</span><span class="s3">] != </span><span class="s1">p</span><span class="s3">:  </span><span class="s0"># prevents both controllers from recalling the same point</span>
<a name="l528"><span class="ln">528  </span></a>                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">p</span>
<a name="l529"><span class="ln">529  </span></a>                                <span class="s2">else</span><span class="s3">:</span>
<a name="l530"><span class="ln">530  </span></a>                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">p</span>
<a name="l531"><span class="ln">531  </span></a>
<a name="l532"><span class="ln">532  </span></a>            <span class="s4">&quot;&quot;&quot; 
<a name="l533"><span class="ln">533  </span></a>            8. if the controller is selecting a point, set its cords to the hand's cords, factoring in the relative position of selection to the hand. 
<a name="l534"><span class="ln">534  </span></a>            9. run point selection animations for the selected point. 
<a name="l535"><span class="ln">535  </span></a>            10. if a point is no longer being selected, reset dragP for the current hand to indicate its deselection. 
<a name="l536"><span class="ln">536  </span></a>            11. if the &quot;recall&quot; button is pressed/held, bring the last selected point (along with all other points in the same cloth) to the current hand's position. 
<a name="l537"><span class="ln">537  </span></a>                teleport for all points in the cloth happens 1 frame after selection. classical movement continues from frame 2 onwards to allow physics to apply to all other points in the cloth. 
<a name="l538"><span class="ln">538  </span></a>            &quot;&quot;&quot;</span>
<a name="l539"><span class="ln">539  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l540"><span class="ln">540  </span></a>                <span class="s0"># set the dragging point's position to the controller that's dragging said point</span>
<a name="l541"><span class="ln">541  </span></a>                <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l542"><span class="ln">542  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__relPos</span><span class="s3">[</span><span class="s1">c</span><span class="s3">][</span><span class="s1">axis</span><span class="s3">]</span>
<a name="l543"><span class="ln">543  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__selectPointAnime</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>
<a name="l544"><span class="ln">544  </span></a>            <span class="s0"># reset drag variables if select button is not pressed</span>
<a name="l545"><span class="ln">545  </span></a>            <span class="s2">if not </span><span class="s1">selectP</span><span class="s3">(</span><span class="s1">c</span><span class="s3">):</span>
<a name="l546"><span class="ln">546  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s2">None</span>
<a name="l547"><span class="ln">547  </span></a>            <span class="s0"># recalls the last clicked point to the controller's position</span>
<a name="l548"><span class="ln">548  </span></a>            <span class="s2">if </span><span class="s1">buttonPressed</span><span class="s3">(</span><span class="s4">'recall'</span><span class="s3">, </span><span class="s1">controlsConf</span><span class="s3">.</span><span class="s1">controllers</span><span class="s3">[</span><span class="s1">c</span><span class="s3">], </span><span class="s1">c</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] &gt;= </span><span class="s5">0</span><span class="s3">):</span>
<a name="l549"><span class="ln">549  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span>
<a name="l550"><span class="ln">550  </span></a>                    <span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">)  </span><span class="s0"># set cords of point to user pointer/hand</span>
<a name="l551"><span class="ln">551  </span></a>                <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'recall'</span><span class="s3">][</span><span class="s1">c</span><span class="s3">]:</span>
<a name="l552"><span class="ln">552  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__tpCloth</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__lastP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">c</span><span class="s3">)</span>
<a name="l553"><span class="ln">553  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__buttonHeld</span><span class="s3">[</span><span class="s4">'recall'</span><span class="s3">][</span><span class="s1">c</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l554"><span class="ln">554  </span></a>
<a name="l555"><span class="ln">555  </span></a>    <span class="s2">def </span><span class="s1">__setRadiusDensityGUI</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">: </span><span class="s1">list</span><span class="s3">, </span><span class="s1">p</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l556"><span class="ln">556  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l557"><span class="ln">557  </span></a>        :param cords: position at which the GUI should be summoned. 
<a name="l558"><span class="ln">558  </span></a>        :param p: index position of the clicked point in the points list. 
<a name="l559"><span class="ln">559  </span></a>        &quot;&quot;&quot;</span>
<a name="l560"><span class="ln">560  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'radius'</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:  </span><span class="s0"># only summon if GUI is empty</span>
<a name="l561"><span class="ln">561  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'radius'</span><span class="s3">] = </span><span class="s1">getSliderManual</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">origRadius</span><span class="s3">,</span>
<a name="l562"><span class="ln">562  </span></a>                                                                <span class="s3">[</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] + </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]], </span><span class="s5">10</span><span class="s3">, </span><span class="s1">maxRadius</span><span class="s3">,</span>
<a name="l563"><span class="ln">563  </span></a>                                                                <span class="s1">minRadius</span><span class="s3">, </span><span class="s4">'Radius'</span><span class="s3">)</span>
<a name="l564"><span class="ln">564  </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l565"><span class="ln">565  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'radius'</span><span class="s3">].</span><span class="s1">unDraw</span><span class="s3">()</span>
<a name="l566"><span class="ln">566  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'radius'</span><span class="s3">] = </span><span class="s2">None</span>
<a name="l567"><span class="ln">567  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'density'</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:  </span><span class="s0"># only summon if GUI is empty</span>
<a name="l568"><span class="ln">568  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'density'</span><span class="s3">] = </span><span class="s1">getSliderManual</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">density</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">origDensity</span><span class="s3">,</span>
<a name="l569"><span class="ln">569  </span></a>                                                                 <span class="s3">[</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]], </span><span class="s5">10</span><span class="s3">, </span><span class="s1">maxDensity</span><span class="s3">,</span>
<a name="l570"><span class="ln">570  </span></a>                                                                 <span class="s1">minDensity</span><span class="s3">, </span><span class="s4">'Density'</span><span class="s3">)</span>
<a name="l571"><span class="ln">571  </span></a>            <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'vr'</span><span class="s3">:</span>
<a name="l572"><span class="ln">572  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'density'</span><span class="s3">].</span><span class="s1">closeButton</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">cords</span><span class="s3">[</span>
<a name="l573"><span class="ln">573  </span></a>                                                                              <span class="s5">1</span><span class="s3">] + </span><span class="s5">1  </span><span class="s0"># offset this 'X' to be within the other 'X' so that they both act as one button to dismiss both radius and density GUIs simultaneously</span>
<a name="l574"><span class="ln">574  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span>
<a name="l575"><span class="ln">575  </span></a>                    <span class="s4">'density'</span><span class="s3">].</span><span class="s1">closeButton</span><span class="s3">.</span><span class="s1">unDraw</span><span class="s3">()  </span><span class="s0"># only one 'X' needs to be rendered, since there are now two Xs within each other</span>
<a name="l576"><span class="ln">576  </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l577"><span class="ln">577  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'density'</span><span class="s3">].</span><span class="s1">unDraw</span><span class="s3">()</span>
<a name="l578"><span class="ln">578  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s4">'slider'</span><span class="s3">][</span><span class="s4">'density'</span><span class="s3">] = </span><span class="s2">None</span>
<a name="l579"><span class="ln">579  </span></a>
<a name="l580"><span class="ln">580  </span></a>    <span class="s0"># animates selecting points depending on if it's being hovered over or selected</span>
<a name="l581"><span class="ln">581  </span></a>    <span class="s2">def </span><span class="s1">__selectPointAnime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">c</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l582"><span class="ln">582  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l583"><span class="ln">583  </span></a>        :param c: controller index value 
<a name="l584"><span class="ln">584  </span></a>        &quot;&quot;&quot;</span>
<a name="l585"><span class="ln">585  </span></a>        <span class="s0"># unique animation for selecting points: https://drive.google.com/file/d/1KWI48WwJub0FmlYfQJStTQ83OMEIPDVs/view?usp=drive_link</span>
<a name="l586"><span class="ln">586  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:  </span><span class="s0"># only run animations if a point is intersecting with a hand</span>
<a name="l587"><span class="ln">587  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dragP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:  </span><span class="s0"># if the point is being selected, run the selection animation</span>
<a name="l588"><span class="ln">588  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">point </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span>
<a name="l589"><span class="ln">589  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]]  </span><span class="s0"># make the selection animation encapsulate the point</span>
<a name="l590"><span class="ln">590  </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] &gt; (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">sphereRad</span><span class="s3">):</span>
<a name="l591"><span class="ln">591  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScaleSpeed </span><span class="s3">-= </span><span class="s5">0.1 </span><span class="s3">/ </span><span class="s1">physicsTime</span>
<a name="l592"><span class="ln">592  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale</span><span class="s3">[</span>
<a name="l593"><span class="ln">593  </span></a>                        <span class="s1">c</span><span class="s3">] += </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScaleSpeed  </span><span class="s0"># accelerate the animation as it wraps around the point</span>
<a name="l594"><span class="ln">594  </span></a>                    <span class="s1">f </span><span class="s3">= </span><span class="s5">6 </span><span class="s3">/ (</span><span class="s1">renderRate </span><span class="s3">* </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span>
<a name="l595"><span class="ln">595  </span></a>                        <span class="s1">c</span><span class="s3">]].</span><span class="s1">radius </span><span class="s3">* </span><span class="s5">10</span><span class="s3">))  </span><span class="s0"># approximate function for changing color with time based on radius: f(x) = 6 / (frequency * sqrt(radius * 10))</span>
<a name="l596"><span class="ln">596  </span></a>                    <span class="s0"># green-shift the animation to give the user the impression that they're gripping the point</span>
<a name="l597"><span class="ln">597  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeColor</span><span class="s3">[</span><span class="s1">c</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] -= </span><span class="s1">f</span>
<a name="l598"><span class="ln">598  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeColor</span><span class="s3">[</span><span class="s1">c</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] += </span><span class="s1">f</span>
<a name="l599"><span class="ln">599  </span></a>                <span class="s2">else</span><span class="s3">:</span>
<a name="l600"><span class="ln">600  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span>
<a name="l601"><span class="ln">601  </span></a>                        <span class="s1">c</span><span class="s3">].</span><span class="s1">sphereRad  </span><span class="s0"># makes the minimum size of the animation equal to the size of the selected point</span>
<a name="l602"><span class="ln">602  </span></a>                    <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">pause </span><span class="s3">= </span><span class="s2">True</span>
<a name="l603"><span class="ln">603  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">setScale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale</span><span class="s3">[</span><span class="s1">c</span><span class="s3">])</span>
<a name="l604"><span class="ln">604  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">setColor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__animeColor</span><span class="s3">[</span><span class="s1">c</span><span class="s3">])</span>
<a name="l605"><span class="ln">605  </span></a>
<a name="l606"><span class="ln">606  </span></a>            <span class="s0"># if the controller is not hovering over a point, return the animation to the hand</span>
<a name="l607"><span class="ln">607  </span></a>            <span class="s2">elif not </span><span class="s1">detectPointCollision</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">radius</span><span class="s3">,</span>
<a name="l608"><span class="ln">608  </span></a>                                          <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">):</span>
<a name="l609"><span class="ln">609  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">point </span><span class="s3">= </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]</span>
<a name="l610"><span class="ln">610  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">resetScale</span><span class="s3">()</span>
<a name="l611"><span class="ln">611  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">resetColor</span><span class="s3">()</span>
<a name="l612"><span class="ln">612  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s2">None</span>
<a name="l613"><span class="ln">613  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">pause </span><span class="s3">= </span><span class="s2">False</span>
<a name="l614"><span class="ln">614  </span></a>
<a name="l615"><span class="ln">615  </span></a>            <span class="s2">else</span><span class="s3">:  </span><span class="s0"># if the hand is hovering over a point, run the hovering animation</span>
<a name="l616"><span class="ln">616  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">point </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]]</span>
<a name="l617"><span class="ln">617  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s5">1.2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collP</span><span class="s3">[</span><span class="s1">c</span><span class="s3">]].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span>
<a name="l618"><span class="ln">618  </span></a>                    <span class="s1">c</span><span class="s3">].</span><span class="s1">sphereRad  </span><span class="s0"># makes the size of the animation 20% larger than the size of the point, taking into account that the animation’s scale is a ratio of its initial size (size of the hand’s point) to its new size</span>
<a name="l619"><span class="ln">619  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScaleSpeed </span><span class="s3">= </span><span class="s5">0</span>
<a name="l620"><span class="ln">620  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__animeColor</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]  </span><span class="s0"># make the animation red</span>
<a name="l621"><span class="ln">621  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">setScale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__animeScale</span><span class="s3">[</span><span class="s1">c</span><span class="s3">])</span>
<a name="l622"><span class="ln">622  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">setColor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__animeColor</span><span class="s3">[</span><span class="s1">c</span><span class="s3">])</span>
<a name="l623"><span class="ln">623  </span></a>                <span class="s1">controls</span><span class="s3">.</span><span class="s1">anim</span><span class="s3">[</span><span class="s1">c</span><span class="s3">].</span><span class="s1">pause </span><span class="s3">= </span><span class="s2">False</span>
<a name="l624"><span class="ln">624  </span></a>
<a name="l625"><span class="ln">625  </span></a>    <span class="s0"># calculate and cache the distance between every point to every other point</span>
<a name="l626"><span class="ln">626  </span></a>    <span class="s2">def </span><span class="s1">__getDist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l627"><span class="ln">627  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l628"><span class="ln">628  </span></a>            <span class="s2">for </span><span class="s1">po </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l629"><span class="ln">629  </span></a>                <span class="s1">sumR </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">radius </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">radius</span>
<a name="l630"><span class="ln">630  </span></a>                <span class="s1">disp </span><span class="s3">= </span><span class="s1">displacement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l631"><span class="ln">631  </span></a>                <span class="s0"># don't detect for collisions if any diff value is greater than the sum of both points' radii. also don't get distance between 2 points if you already have it! this is a performance optimization that essentially halves the time complexity of this function, which is O(n²).</span>
<a name="l632"><span class="ln">632  </span></a>                <span class="s2">if </span><span class="s3">(((</span><span class="s1">disp</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt;= </span><span class="s1">sumR</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">disp</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">sumR</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">disp</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= </span><span class="s1">sumR</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l633"><span class="ln">633  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">po</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">po </span><span class="s3">&gt; </span><span class="s1">p</span><span class="s3">):</span>
<a name="l634"><span class="ln">634  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">p</span><span class="s3">][</span><span class="s1">po</span><span class="s3">] = </span><span class="s1">diffDistance</span><span class="s3">(</span><span class="s1">disp</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">disp</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">disp</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l635"><span class="ln">635  </span></a>
<a name="l636"><span class="ln">636  </span></a>    <span class="s0"># add a point object to the points list</span>
<a name="l637"><span class="ln">637  </span></a>    <span class="s2">def </span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">point</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l638"><span class="ln">638  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l639"><span class="ln">639  </span></a>        :param point: point object to add to the points list 
<a name="l640"><span class="ln">640  </span></a>        &quot;&quot;&quot;</span>
<a name="l641"><span class="ln">641  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">point</span><span class="s3">)</span>
<a name="l642"><span class="ln">642  </span></a>        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l643"><span class="ln">643  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">pIdx </span><span class="s3">= </span><span class="s1">p</span>
<a name="l644"><span class="ln">644  </span></a>
<a name="l645"><span class="ln">645  </span></a>    <span class="s0"># draw and update all the summoned GUIs</span>
<a name="l646"><span class="ln">646  </span></a>    <span class="s2">def </span><span class="s1">__updateGUI</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l647"><span class="ln">647  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l648"><span class="ln">648  </span></a>        this method is used to update all the summoned GUIs. 
<a name="l649"><span class="ln">649  </span></a>        gVar: GUI's reference variable 
<a name="l650"><span class="ln">650  </span></a>        gType: type of GUI (slider, dial, manual) 
<a name="l651"><span class="ln">651  </span></a>        gAxis: which axis the GUI is about 
<a name="l652"><span class="ln">652  </span></a>        self.__GUI[gVar][gType][gAxis]: the current GUI object 
<a name="l653"><span class="ln">653  </span></a> 
<a name="l654"><span class="ln">654  </span></a>        process: 
<a name="l655"><span class="ln">655  </span></a>            1. loop through each GUI. if the GUI exists, continue. 
<a name="l656"><span class="ln">656  </span></a>            2. if the GUI is drawn, continue. otherwise, remove the GUI object from the 'GUI' dictionary. 
<a name="l657"><span class="ln">657  </span></a>            3. handle an exception in which the GUI selector is summoned, since it'll return the selected GUI by the user to the 'GUIType' variable. 
<a name="l658"><span class="ln">658  </span></a>            4. if the 'gVar' isn't an integer (meaning it's not a point index), then that must mean that the GUI's reference variable maps to a variable in the 'globalVars' dictionary. if so: 
<a name="l659"><span class="ln">659  </span></a>                a) as long as the GUI isn't a tutorial, set its reference variable to the variable it maps to and update the variable it maps to its reference variable. 
<a name="l660"><span class="ln">660  </span></a>                b) otherwise, if the GUI is a tutorial, just run its main function to check if it's being dismissed by the user. 
<a name="l661"><span class="ln">661  </span></a>            5. otherwise, that must mean that the current GUI's reference variable maps to either the radius or density of a point. 
<a name="l662"><span class="ln">662  </span></a>                the index position of this point in the points list is represented by 'gVar' ONLY if 'gVar' is an integer. 
<a name="l663"><span class="ln">663  </span></a> 
<a name="l664"><span class="ln">664  </span></a>        'setVar' is used to update the variable of this GUI if multiple GUIs are summoned that have a common variable. 
<a name="l665"><span class="ln">665  </span></a>            this allows for multiple GUIs to affect each other, which looks very cool! 
<a name="l666"><span class="ln">666  </span></a>        one line after 'setVar' is called, the variable that the GUI changes is updated. the reason this is after 'setVar' is to prevent a recursive state in which the variable never changes. 
<a name="l667"><span class="ln">667  </span></a>        &quot;&quot;&quot;</span>
<a name="l668"><span class="ln">668  </span></a>        <span class="s2">for </span><span class="s1">gVar </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">:</span>
<a name="l669"><span class="ln">669  </span></a>            <span class="s2">for </span><span class="s1">gType </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">]:</span>
<a name="l670"><span class="ln">670  </span></a>                <span class="s2">for </span><span class="s1">gAxis </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">][</span><span class="s1">gType</span><span class="s3">]:</span>
<a name="l671"><span class="ln">671  </span></a>                    <span class="s1">currentGUI </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">][</span><span class="s1">gType</span><span class="s3">][</span><span class="s1">gAxis</span><span class="s3">]  </span><span class="s0"># alias for the current GUI object</span>
<a name="l672"><span class="ln">672  </span></a>                    <span class="s2">if </span><span class="s1">currentGUI </span><span class="s2">is not None</span><span class="s3">:  </span><span class="s0"># if the GUI currently exists</span>
<a name="l673"><span class="ln">673  </span></a>                        <span class="s2">if </span><span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">drawn</span><span class="s3">:  </span><span class="s0"># if the GUI is currently summoned</span>
<a name="l674"><span class="ln">674  </span></a>                            <span class="s2">if </span><span class="s1">gVar </span><span class="s3">== </span><span class="s4">'GUISelector'</span><span class="s3">:  </span><span class="s0"># if the GUISelector is to be summoned, get its result in self.GUIType</span>
<a name="l675"><span class="ln">675  </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType </span><span class="s3">= </span><span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">main</span><span class="s3">()</span>
<a name="l676"><span class="ln">676  </span></a>                            <span class="s2">else</span><span class="s3">:</span>
<a name="l677"><span class="ln">677  </span></a>                                <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">gVar</span><span class="s3">) </span><span class="s2">is not </span><span class="s1">int</span><span class="s3">:  </span><span class="s0"># if gVar isn't a point index</span>
<a name="l678"><span class="ln">678  </span></a>                                    <span class="s2">if </span><span class="s1">gVar </span><span class="s3">!= </span><span class="s4">'Tutorials'</span><span class="s3">:</span>
<a name="l679"><span class="ln">679  </span></a>                                        <span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">setVar</span><span class="s3">(</span><span class="s1">globalVars</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">])</span>
<a name="l680"><span class="ln">680  </span></a>                                        <span class="s1">globalVars</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">] = </span><span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">main</span><span class="s3">()</span>
<a name="l681"><span class="ln">681  </span></a>                                    <span class="s2">else</span><span class="s3">:  </span><span class="s0"># if the GUI is a tutorial, don't do any fancy stuff. just run its main method!</span>
<a name="l682"><span class="ln">682  </span></a>                                        <span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">main</span><span class="s3">()</span>
<a name="l683"><span class="ln">683  </span></a>                                <span class="s2">else</span><span class="s3">:  </span><span class="s0"># if the GUI was summoned as a result of double-clicking on a point, update the radius and density of that point</span>
<a name="l684"><span class="ln">684  </span></a>                                    <span class="s2">if </span><span class="s1">gAxis </span><span class="s3">== </span><span class="s4">'radius'</span><span class="s3">:</span>
<a name="l685"><span class="ln">685  </span></a>                                        <span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">setVar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">].</span><span class="s1">radius</span><span class="s3">)</span>
<a name="l686"><span class="ln">686  </span></a>                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">].</span><span class="s1">setRadiusDensity</span><span class="s3">(</span><span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">main</span><span class="s3">(), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">].</span><span class="s1">density</span><span class="s3">)</span>
<a name="l687"><span class="ln">687  </span></a>                                    <span class="s2">elif </span><span class="s1">gAxis </span><span class="s3">== </span><span class="s4">'density'</span><span class="s3">:</span>
<a name="l688"><span class="ln">688  </span></a>                                        <span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">setVar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">].</span><span class="s1">density</span><span class="s3">)</span>
<a name="l689"><span class="ln">689  </span></a>                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">].</span><span class="s1">setRadiusDensity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">].</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">currentGUI</span><span class="s3">.</span><span class="s1">main</span><span class="s3">())</span>
<a name="l690"><span class="ln">690  </span></a>                        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># if the GUI is to be removed (since it's no longer drawn)</span>
<a name="l691"><span class="ln">691  </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">gVar</span><span class="s3">][</span><span class="s1">gType</span><span class="s3">][</span><span class="s1">gAxis</span><span class="s3">] = </span><span class="s2">None</span>
<a name="l692"><span class="ln">692  </span></a>
<a name="l693"><span class="ln">693  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__selectGUIType</span><span class="s3">()</span>
<a name="l694"><span class="ln">694  </span></a>
<a name="l695"><span class="ln">695  </span></a>    <span class="s0"># summons a GUI if self.GUIType has a value, running through all the possible case scenarios and exceptions for different variables</span>
<a name="l696"><span class="ln">696  </span></a>    <span class="s2">def </span><span class="s1">__selectGUIType</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l697"><span class="ln">697  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l698"><span class="ln">698  </span></a>        this method is used to summon a GUI if 'GUIType' isn't None, running through all the possible case scenarios and exceptions for different variables and GUI types. 
<a name="l699"><span class="ln">699  </span></a>        different case scenarios cause the data returned from 'GUIType' to vary. this method also runs through all these scenarios. 
<a name="l700"><span class="ln">700  </span></a>        all GUIs summoned first check to see if they have been summoned previously. if so, they are removed and re-summoned at the hand's position. 
<a name="l701"><span class="ln">701  </span></a>        all GUI objects are provided with the objects of both controllers so that they can detect interactions between them ('lController' &amp; 'rController' constants). 
<a name="l702"><span class="ln">702  </span></a> 
<a name="l703"><span class="ln">703  </span></a>        process: 
<a name="l704"><span class="ln">704  </span></a>            1. if a cloth was selected from the GUI selector, teleport it to the controller's position. 
<a name="l705"><span class="ln">705  </span></a>                this is the only non-GUI option from the GUI selector. 
<a name="l706"><span class="ln">706  </span></a>            2. if a tutorial was selected from the GUI selector, summon the selected tutorial to the hand's position. 
<a name="l707"><span class="ln">707  </span></a>            3. if a variable was selected, check for its type: 
<a name="l708"><span class="ln">708  </span></a>                a) if the selected GUI type is a slider: 
<a name="l709"><span class="ln">709  </span></a>                    1) pass in the necessary variables to initialize the slider. 
<a name="l710"><span class="ln">710  </span></a>                b) if the selected GUI type is a dial (user can only select this option if the reference variable is a vector quantity): 
<a name="l711"><span class="ln">711  </span></a>                    1) append a copy of the dimension of the dial (2D/3D) to the end of the GUIType list. 
<a name="l712"><span class="ln">712  </span></a>                        this is used to generalize the dial's reference in the 'GUI' dictionary to indicate if the dial is 3D. 
<a name="l713"><span class="ln">713  </span></a>                    2) if the dial is 2D, get the two axes on which the reference variable is to be changed, mapping the axes selected to two indexes. 
<a name="l714"><span class="ln">714  </span></a>                        indicate this by making the length of the 'maxi' and 'mini' lists passed into the Dial class to 2. 
<a name="l715"><span class="ln">715  </span></a>                    3) if the dial is 3D, all three axes will always be changed. 
<a name="l716"><span class="ln">716  </span></a>                        indicate this by making the length of the 'maxi' and 'mini' values passed into the Dial class to 3. 
<a name="l717"><span class="ln">717  </span></a>                c) if the selected GUI type is a manual input: 
<a name="l718"><span class="ln">718  </span></a>                    1) pass in the necessary variables to initialize the manual input. 
<a name="l719"><span class="ln">719  </span></a>            4. after this, always reset the value of 'GUIType' to None so that only one GUI is summoned. 
<a name="l720"><span class="ln">720  </span></a>        &quot;&quot;&quot;</span>
<a name="l721"><span class="ln">721  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l722"><span class="ln">722  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'cloths'</span><span class="s3">:</span>
<a name="l723"><span class="ln">723  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__tpCloth</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">], </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l724"><span class="ln">724  </span></a>            <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'Tutorials'</span><span class="s3">:</span>
<a name="l725"><span class="ln">725  </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s4">''</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]] </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l726"><span class="ln">726  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s4">''</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]].</span><span class="s1">unDraw</span><span class="s3">()</span>
<a name="l727"><span class="ln">727  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s4">''</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]] = </span><span class="s2">None</span>
<a name="l728"><span class="ln">728  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s4">''</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Tutorial</span><span class="s3">(</span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">,</span>
<a name="l729"><span class="ln">729  </span></a>                                                                                         <span class="s3">[</span><span class="s5">10</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">],</span>
<a name="l730"><span class="ln">730  </span></a>                                                                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">__tutorialTexts</span><span class="s3">[</span>
<a name="l731"><span class="ln">731  </span></a>                                                                                             <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]], [],</span>
<a name="l732"><span class="ln">732  </span></a>                                                                                         <span class="s5">0.3</span><span class="s3">, </span><span class="s1">lControllerObj</span><span class="s3">,</span>
<a name="l733"><span class="ln">733  </span></a>                                                                                         <span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l734"><span class="ln">734  </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l735"><span class="ln">735  </span></a>                <span class="s0"># make some aliases for long variable names</span>
<a name="l736"><span class="ln">736  </span></a>                <span class="s1">maxValue </span><span class="s3">= </span><span class="s1">globalRanges</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s5">0</span><span class="s3">]</span>
<a name="l737"><span class="ln">737  </span></a>                <span class="s1">minValue </span><span class="s3">= </span><span class="s1">globalRanges</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s5">1</span><span class="s3">]</span>
<a name="l738"><span class="ln">738  </span></a>                <span class="s1">refVar </span><span class="s3">= </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>
<a name="l739"><span class="ln">739  </span></a>                <span class="s1">defRefVar </span><span class="s3">= </span><span class="s1">defaultGlobalVars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>
<a name="l740"><span class="ln">740  </span></a>
<a name="l741"><span class="ln">741  </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'Slider'</span><span class="s3">:</span>
<a name="l742"><span class="ln">742  </span></a>                    <span class="s1">xyz </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__setupSliderManual</span><span class="s3">()</span>
<a name="l743"><span class="ln">743  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Slider</span><span class="s3">(</span>
<a name="l744"><span class="ln">744  </span></a>                        <span class="s1">xyz</span><span class="s3">, </span><span class="s1">refVar</span><span class="s3">, </span><span class="s1">defRefVar</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s1">maxValue</span><span class="s3">, </span><span class="s1">minValue</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">],</span>
<a name="l745"><span class="ln">745  </span></a>                        <span class="s1">lControllerObj</span><span class="s3">, </span><span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l746"><span class="ln">746  </span></a>
<a name="l747"><span class="ln">747  </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'Dial'</span><span class="s3">:</span>
<a name="l748"><span class="ln">748  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span>
<a name="l749"><span class="ln">749  </span></a>                                                 <span class="s5">1</span><span class="s3">])  </span><span class="s0"># make 'GUIType[1][2]' equal to 'GUIType[1][1]', which is whether the dial is 2D or 3D</span>
<a name="l750"><span class="ln">750  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">]] </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l751"><span class="ln">751  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">]].</span><span class="s1">unDraw</span><span class="s3">()</span>
<a name="l752"><span class="ln">752  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">]] = </span><span class="s2">None</span>
<a name="l753"><span class="ln">753  </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span>
<a name="l754"><span class="ln">754  </span></a>                        <span class="s5">1</span><span class="s3">] == </span><span class="s4">'2D'</span><span class="s3">:  </span><span class="s0"># if the dial is 2D, it will need to be provided with an axis representing the two values of the variable's list that should be changed</span>
<a name="l755"><span class="ln">755  </span></a>                        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">] == </span><span class="s4">'XZ'</span><span class="s3">:</span>
<a name="l756"><span class="ln">756  </span></a>                            <span class="s1">xyz </span><span class="s3">= </span><span class="s5">0</span>
<a name="l757"><span class="ln">757  </span></a>                        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">] == </span><span class="s4">'XY'</span><span class="s3">:</span>
<a name="l758"><span class="ln">758  </span></a>                            <span class="s1">xyz </span><span class="s3">= </span><span class="s5">1</span>
<a name="l759"><span class="ln">759  </span></a>                        <span class="s2">else</span><span class="s3">:</span>
<a name="l760"><span class="ln">760  </span></a>                            <span class="s1">xyz </span><span class="s3">= </span><span class="s5">2</span>
<a name="l761"><span class="ln">761  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">]] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Dial</span><span class="s3">(</span>
<a name="l762"><span class="ln">762  </span></a>                            <span class="s1">xyz</span><span class="s3">, </span><span class="s1">refVar</span><span class="s3">, </span><span class="s1">defRefVar</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, [</span><span class="s1">maxValue</span><span class="s3">, </span><span class="s1">maxValue</span><span class="s3">],</span>
<a name="l763"><span class="ln">763  </span></a>                            <span class="s3">[</span><span class="s1">minValue</span><span class="s3">, </span><span class="s1">minValue</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">], </span><span class="s1">lControllerObj</span><span class="s3">, </span><span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l764"><span class="ln">764  </span></a>                    <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span>
<a name="l765"><span class="ln">765  </span></a>                        <span class="s5">1</span><span class="s3">] == </span><span class="s4">'3D'</span><span class="s3">:  </span><span class="s0"># if the dial is 3D, no axis needs to be provided since it will change all three of the variable's values in its list (basically means axis is XYZ)</span>
<a name="l766"><span class="ln">766  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">2</span><span class="s3">]] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Dial</span><span class="s3">(</span>
<a name="l767"><span class="ln">767  </span></a>                            <span class="s5">0</span><span class="s3">, </span><span class="s1">refVar</span><span class="s3">, </span><span class="s1">defRefVar</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, [</span><span class="s1">maxValue</span><span class="s3">, </span><span class="s1">maxValue</span><span class="s3">, </span><span class="s1">maxValue</span><span class="s3">],</span>
<a name="l768"><span class="ln">768  </span></a>                            <span class="s3">[</span><span class="s1">minValue</span><span class="s3">, </span><span class="s1">minValue</span><span class="s3">, </span><span class="s1">minValue</span><span class="s3">], </span><span class="s4">'XYZ'</span><span class="s3">, </span><span class="s1">lControllerObj</span><span class="s3">, </span><span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l769"><span class="ln">769  </span></a>
<a name="l770"><span class="ln">770  </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'Manual'</span><span class="s3">:</span>
<a name="l771"><span class="ln">771  </span></a>                    <span class="s1">xyz </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__setupSliderManual</span><span class="s3">()</span>
<a name="l772"><span class="ln">772  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]] = </span><span class="s1">myGUI</span><span class="s3">.</span><span class="s1">Manual</span><span class="s3">(</span>
<a name="l773"><span class="ln">773  </span></a>                        <span class="s1">xyz</span><span class="s3">, </span><span class="s1">refVar</span><span class="s3">, </span><span class="s1">defRefVar</span><span class="s3">, </span><span class="s1">controls</span><span class="s3">.</span><span class="s1">hand</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">lControllerObj</span><span class="s3">,</span>
<a name="l774"><span class="ln">774  </span></a>                        <span class="s1">rControllerObj</span><span class="s3">)</span>
<a name="l775"><span class="ln">775  </span></a>
<a name="l776"><span class="ln">776  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType </span><span class="s3">= </span><span class="s2">None</span>
<a name="l777"><span class="ln">777  </span></a>
<a name="l778"><span class="ln">778  </span></a>    <span class="s0"># set up the GUI and axes of a slider or manual GUI</span>
<a name="l779"><span class="ln">779  </span></a>    <span class="s2">def </span><span class="s1">__setupSliderManual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
<a name="l780"><span class="ln">780  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l781"><span class="ln">781  </span></a>        :return: index position of the axis about which the GUI is situated. 
<a name="l782"><span class="ln">782  </span></a>        &quot;&quot;&quot;</span>
<a name="l783"><span class="ln">783  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]] </span><span class="s2">is not None</span><span class="s3">:</span>
<a name="l784"><span class="ln">784  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]].</span><span class="s1">unDraw</span><span class="s3">()</span>
<a name="l785"><span class="ln">785  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__GUI</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">()][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]] = </span><span class="s2">None</span>
<a name="l786"><span class="ln">786  </span></a>        <span class="s0"># get the axis' index on which the GUI is situated</span>
<a name="l787"><span class="ln">787  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] == </span><span class="s4">'X'</span><span class="s3">:</span>
<a name="l788"><span class="ln">788  </span></a>            <span class="s1">xyz </span><span class="s3">= </span><span class="s5">0</span>
<a name="l789"><span class="ln">789  </span></a>        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__GUIType</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] == </span><span class="s4">'Y'</span><span class="s3">:</span>
<a name="l790"><span class="ln">790  </span></a>            <span class="s1">xyz </span><span class="s3">= </span><span class="s5">1</span>
<a name="l791"><span class="ln">791  </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l792"><span class="ln">792  </span></a>            <span class="s1">xyz </span><span class="s3">= </span><span class="s5">2</span>
<a name="l793"><span class="ln">793  </span></a>        <span class="s2">return </span><span class="s1">xyz</span>
<a name="l794"><span class="ln">794  </span></a>
<a name="l795"><span class="ln">795  </span></a>
<a name="l796"><span class="ln">796  </span></a><span class="s0"># class for spheres</span>
<a name="l797"><span class="ln">797  </span></a><span class="s2">class </span><span class="s1">Point</span><span class="s3">:</span>
<a name="l798"><span class="ln">798  </span></a>    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">density</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">show</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, *</span><span class="s1">disabledPointCollisions</span><span class="s3">: </span><span class="s1">list</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l799"><span class="ln">799  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">show </span><span class="s3">= </span><span class="s1">show  </span><span class="s0"># boolean value of whether to draw the point in the Vizard game scene</span>
<a name="l800"><span class="ln">800  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">= </span><span class="s1">radius</span>
<a name="l801"><span class="ln">801  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">origRadius </span><span class="s3">= </span><span class="s1">radius</span>
<a name="l802"><span class="ln">802  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">show</span><span class="s3">:</span>
<a name="l803"><span class="ln">803  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">sphere </span><span class="s3">= </span><span class="s1">vizshape</span><span class="s3">.</span><span class="s1">addSphere</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">slices</span><span class="s3">=</span><span class="s1">pointResolution</span><span class="s3">)  </span><span class="s0"># vizard object for sphere</span>
<a name="l804"><span class="ln">804  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">sphere</span><span class="s3">.</span><span class="s1">setScale</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">])</span>
<a name="l805"><span class="ln">805  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l806"><span class="ln">806  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]  </span><span class="s0"># coordinate position from last frame</span>
<a name="l807"><span class="ln">807  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">velocity </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l808"><span class="ln">808  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__force </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l809"><span class="ln">809  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__normalForce </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
<a name="l810"><span class="ln">810  </span></a>                              <span class="s5">0</span><span class="s3">]  </span><span class="s0"># here's how I'll calculate this when on a vertex: https://drive.google.com/file/d/1ES6T8RilTcE5Pu7Zhdxfo6R6hvvsViAT/view?usp=drive_link</span>
<a name="l811"><span class="ln">811  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__acc </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l812"><span class="ln">812  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">density </span><span class="s3">= </span><span class="s1">density</span>
<a name="l813"><span class="ln">813  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">origDensity </span><span class="s3">= </span><span class="s1">density</span>
<a name="l814"><span class="ln">814  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__volume </span><span class="s3">= (</span><span class="s5">4 </span><span class="s3">/ </span><span class="s5">3</span><span class="s3">) * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">3</span>
<a name="l815"><span class="ln">815  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__halfArea </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">2</span>
<a name="l816"><span class="ln">816  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">density </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume</span>
<a name="l817"><span class="ln">817  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__weight </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span><span class="s5">0</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span><span class="s5">1</span><span class="s3">],</span>
<a name="l818"><span class="ln">818  </span></a>                         <span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span><span class="s5">2</span><span class="s3">]]</span>
<a name="l819"><span class="ln">819  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__gasDrag </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l820"><span class="ln">820  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidDrag </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l821"><span class="ln">821  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__gasUpthrust </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l822"><span class="ln">822  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidUpthrust </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l823"><span class="ln">823  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l824"><span class="ln">824  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l825"><span class="ln">825  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l826"><span class="ln">826  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollision </span><span class="s3">= []</span>
<a name="l827"><span class="ln">827  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollisionCalc </span><span class="s3">= []</span>
<a name="l828"><span class="ln">828  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cubeSubmersion </span><span class="s3">= []</span>
<a name="l829"><span class="ln">829  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">collision </span><span class="s3">= []  </span><span class="s0"># stores the surface of every collisionRect that the point's center is CURRENTLY in front</span>
<a name="l830"><span class="ln">830  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision </span><span class="s3">= []</span>
<a name="l831"><span class="ln">831  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">= </span><span class="s4">''  </span><span class="s0"># nearest vertex plane's axis</span>
<a name="l832"><span class="ln">832  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s5">1  </span><span class="s0"># elasticity coefficient</span>
<a name="l833"><span class="ln">833  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">= </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'friction'</span><span class="s3">]  </span><span class="s0"># surface friction coefficient</span>
<a name="l834"><span class="ln">834  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier </span><span class="s3">= []  </span><span class="s0"># stores values used in calculations to get direction of motion</span>
<a name="l835"><span class="ln">835  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cloth </span><span class="s3">= </span><span class="s4">''</span>
<a name="l836"><span class="ln">836  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]  </span><span class="s0"># direction of motion</span>
<a name="l837"><span class="ln">837  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">= </span><span class="s4">''  </span><span class="s0"># indicate whether to use 'y = mx + c' or 'x = my + c'</span>
<a name="l838"><span class="ln">838  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]  </span><span class="s0"># stores a copy of the angle of the current collisionRect</span>
<a name="l839"><span class="ln">839  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">colliding </span><span class="s3">= []</span>
<a name="l840"><span class="ln">840  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">pIdx </span><span class="s3">= </span><span class="s4">''</span>
<a name="l841"><span class="ln">841  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume </span><span class="s3">= </span><span class="s5">0</span>
<a name="l842"><span class="ln">842  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedArea </span><span class="s3">= </span><span class="s5">0</span>
<a name="l843"><span class="ln">843  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedRadius </span><span class="s3">= </span><span class="s5">0</span>
<a name="l844"><span class="ln">844  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__xCollisionLine </span><span class="s3">= </span><span class="s2">None</span>
<a name="l845"><span class="ln">845  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine </span><span class="s3">= </span><span class="s2">None</span>
<a name="l846"><span class="ln">846  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">disabledPointCollisions </span><span class="s3">= [</span><span class="s4">''</span><span class="s3">]  </span><span class="s0"># variable for the experimental Joint.snap() method</span>
<a name="l847"><span class="ln">847  </span></a>        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">disabledPointCollisions</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
<a name="l848"><span class="ln">848  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">disabledPointCollisions </span><span class="s3">= </span><span class="s1">disabledPointCollisions</span>
<a name="l849"><span class="ln">849  </span></a>
<a name="l850"><span class="ln">850  </span></a>    <span class="s0"># setter method that increments the size of the point's 'multiplier' list</span>
<a name="l851"><span class="ln">851  </span></a>    <span class="s2">def </span><span class="s1">incrementMultiplier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l852"><span class="ln">852  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
<a name="l853"><span class="ln">853  </span></a>
<a name="l854"><span class="ln">854  </span></a>    <span class="s2">def </span><span class="s1">teleport</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">: </span><span class="s1">list</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l855"><span class="ln">855  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l856"><span class="ln">856  </span></a>        :param cords: position to which this point (self) should be teleported to. 
<a name="l857"><span class="ln">857  </span></a>        &quot;&quot;&quot;</span>
<a name="l858"><span class="ln">858  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l859"><span class="ln">859  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l860"><span class="ln">860  </span></a>
<a name="l861"><span class="ln">861  </span></a>    <span class="s0"># this setter method is used to set the values for radius and density so that volume, surface area, and mass can be recalculated</span>
<a name="l862"><span class="ln">862  </span></a>    <span class="s2">def </span><span class="s1">setRadiusDensity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">density</span><span class="s3">: </span><span class="s1">float</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l863"><span class="ln">863  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l864"><span class="ln">864  </span></a>        :param radius: new radius of this point. 
<a name="l865"><span class="ln">865  </span></a>        :param density: new density of this point. 
<a name="l866"><span class="ln">866  </span></a>        &quot;&quot;&quot;</span>
<a name="l867"><span class="ln">867  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">= </span><span class="s1">radius</span>
<a name="l868"><span class="ln">868  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">density </span><span class="s3">= </span><span class="s1">density</span>
<a name="l869"><span class="ln">869  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__volume </span><span class="s3">= </span><span class="s5">4 </span><span class="s3">/ </span><span class="s5">3 </span><span class="s3">* </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">3</span>
<a name="l870"><span class="ln">870  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__halfArea </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">2</span>
<a name="l871"><span class="ln">871  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">density </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume</span>
<a name="l872"><span class="ln">872  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">show</span><span class="s3">:</span>
<a name="l873"><span class="ln">873  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">sphere</span><span class="s3">.</span><span class="s1">setScale</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">])</span>
<a name="l874"><span class="ln">874  </span></a>
<a name="l875"><span class="ln">875  </span></a>    <span class="s2">def </span><span class="s1">move</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l876"><span class="ln">876  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__weight </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span><span class="s5">0</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span><span class="s5">1</span><span class="s3">],</span>
<a name="l877"><span class="ln">877  </span></a>                         <span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span>
<a name="l878"><span class="ln">878  </span></a>                             <span class="s5">2</span><span class="s3">]]  </span><span class="s0"># update weight of the point since gField can be changed in a GUI</span>
<a name="l879"><span class="ln">879  </span></a>
<a name="l880"><span class="ln">880  </span></a>        <span class="s2">if not </span><span class="s1">game</span><span class="s3">.</span><span class="s1">pause</span><span class="s3">:</span>
<a name="l881"><span class="ln">881  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__physics</span><span class="s3">()</span>
<a name="l882"><span class="ln">882  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__boxCollision</span><span class="s3">()  </span><span class="s0"># runs collision code</span>
<a name="l883"><span class="ln">883  </span></a>
<a name="l884"><span class="ln">884  </span></a>        <span class="s0"># Verlet integration</span>
<a name="l885"><span class="ln">885  </span></a>        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l886"><span class="ln">886  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span>
<a name="l887"><span class="ln">887  </span></a>                <span class="s1">axis</span><span class="s3">]) * </span><span class="s1">physicsTime  </span><span class="s0"># set velocity to change in position</span>
<a name="l888"><span class="ln">888  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)  </span><span class="s0"># cords for this frame is set to oldCords for next frame</span>
<a name="l889"><span class="ln">889  </span></a>
<a name="l890"><span class="ln">890  </span></a>        <span class="s2">if not </span><span class="s1">game</span><span class="s3">.</span><span class="s1">pause</span><span class="s3">:</span>
<a name="l891"><span class="ln">891  </span></a>            <span class="s0"># move the point based on its velocity</span>
<a name="l892"><span class="ln">892  </span></a>            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l893"><span class="ln">893  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">v</span><span class="s3">] += </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">v</span><span class="s3">] / </span><span class="s1">physicsTime</span>
<a name="l894"><span class="ln">894  </span></a>
<a name="l895"><span class="ln">895  </span></a>    <span class="s2">def </span><span class="s1">draw</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l896"><span class="ln">896  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">show</span><span class="s3">:</span>
<a name="l897"><span class="ln">897  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">sphere</span><span class="s3">.</span><span class="s1">setPosition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l898"><span class="ln">898  </span></a>
<a name="l899"><span class="ln">899  </span></a>    <span class="s2">def </span><span class="s1">__physics</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l900"><span class="ln">900  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l901"><span class="ln">901  </span></a>        this method is used to calculate and manage all the physics for this point. 
<a name="l902"><span class="ln">902  </span></a> 
<a name="l903"><span class="ln">903  </span></a>        process: 
<a name="l904"><span class="ln">904  </span></a>            1. loop through all three axes XYZ. 
<a name="l905"><span class="ln">905  </span></a>            2. calculate drag caused by the air using the following formula: &quot;1/2 * density * area * velocity² * -getSign(velocity)&quot; 
<a name="l906"><span class="ln">906  </span></a>                this formula was obtained from https://en.wikipedia.org/wiki/Drag_equation 
<a name="l907"><span class="ln">907  </span></a>                gas drag acts in the opposite direction to motion, hence getting the opposite sign of velocity. 
<a name="l908"><span class="ln">908  </span></a>            3. calculate upthrust caused by the air using the following formula: &quot;-volume * weight&quot; 
<a name="l909"><span class="ln">909  </span></a>                negative coefficient used here since upthrust always acts in the opposite direction to gField. 
<a name="l910"><span class="ln">910  </span></a>            4. sum all the forces together in a resultant force value. 
<a name="l911"><span class="ln">911  </span></a>                different types of forces are stored in different variables since it makes them a lot easier to identify and manage, and also to reassign each frame. 
<a name="l912"><span class="ln">912  </span></a>            5. check for collisions with any collisionRect. 
<a name="l913"><span class="ln">913  </span></a>            6. add normal reaction force, friction, and impulse caused by a collision with a collisionRect to resultant force. 
<a name="l914"><span class="ln">914  </span></a>                these values are all 0 if there's no collision with a collisionRect. 
<a name="l915"><span class="ln">915  </span></a>                these values are added to the resultant force last, since they are external forces that depend on the magnitude and direction of all other forces. 
<a name="l916"><span class="ln">916  </span></a>            7. calculate acceleration using &quot;a = F / m&quot;, and update oldCords to cause a change in velocity from Verlet integration. 
<a name="l917"><span class="ln">917  </span></a>                v = d / t and a = v / t, thus d = a * t². t² is actually divided instead of multiplied since physicsTime is a frequency. 
<a name="l918"><span class="ln">918  </span></a>            8. calculate the direction of motion for use in friction calculations. 
<a name="l919"><span class="ln">919  </span></a>        &quot;&quot;&quot;</span>
<a name="l920"><span class="ln">920  </span></a>        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l921"><span class="ln">921  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__gasDrag</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gasDensity'</span><span class="s3">] * -</span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]) * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* (</span>
<a name="l922"><span class="ln">922  </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">2</span><span class="s3">) * ((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span>
<a name="l923"><span class="ln">923  </span></a>                                                  <span class="s1">axis</span><span class="s3">] / </span><span class="s1">physicsTime</span><span class="s3">) ** </span><span class="s5">2</span><span class="s3">)  </span><span class="s0"># divide velocity by 'physicsTime' so that the magnitude of gasDrag can always remain constant, regardless of physicsTime</span>
<a name="l924"><span class="ln">924  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__gasUpthrust</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = -(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume</span><span class="s3">) * </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gasDensity'</span><span class="s3">] * </span><span class="s1">\</span>
<a name="l925"><span class="ln">925  </span></a>                                       <span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span><span class="s1">axis</span><span class="s3">]</span>
<a name="l926"><span class="ln">926  </span></a>
<a name="l927"><span class="ln">927  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__gasDrag</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidDrag</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__gasUpthrust</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">\</span>
<a name="l928"><span class="ln">928  </span></a>                                 <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidUpthrust</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__weight</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce</span><span class="s3">[</span>
<a name="l929"><span class="ln">929  </span></a>                                     <span class="s1">axis</span><span class="s3">]  </span><span class="s0"># get resultant force</span>
<a name="l930"><span class="ln">930  </span></a>
<a name="l931"><span class="ln">931  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__resolveRectCollisions</span><span class="s3">()</span>
<a name="l932"><span class="ln">932  </span></a>
<a name="l933"><span class="ln">933  </span></a>        <span class="s0"># add all forces together and calculate acceleration from this resultant force</span>
<a name="l934"><span class="ln">934  </span></a>        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l935"><span class="ln">935  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] += </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__normalForce</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__friction</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
<a name="l936"><span class="ln">936  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># only run physics if the particle's radius isn't 0 to prevent ZeroDivisionError</span>
<a name="l937"><span class="ln">937  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__acc</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass  </span><span class="s0"># F = ma, thus a = F / m</span>
<a name="l938"><span class="ln">938  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] -= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__acc</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] / (</span><span class="s1">physicsTime </span><span class="s3">** </span><span class="s5">2</span><span class="s3">)  </span><span class="s0"># divide by time since d(s) = a / d(f)²</span>
<a name="l939"><span class="ln">939  </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l940"><span class="ln">940  </span></a>
<a name="l941"><span class="ln">941  </span></a>        <span class="s0"># direction of motion relative to each axis in the form [x:y, x:z, y:z]</span>
<a name="l942"><span class="ln">942  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># prevents dividing by 0</span>
<a name="l943"><span class="ln">943  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">math</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
<a name="l944"><span class="ln">944  </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l945"><span class="ln">945  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l946"><span class="ln">946  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:</span>
<a name="l947"><span class="ln">947  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">math</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l948"><span class="ln">948  </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l949"><span class="ln">949  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l950"><span class="ln">950  </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:</span>
<a name="l951"><span class="ln">951  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">math</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
<a name="l952"><span class="ln">952  </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l953"><span class="ln">953  </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l954"><span class="ln">954  </span></a>
<a name="l955"><span class="ln">955  </span></a>    <span class="s2">def </span><span class="s1">__resolveRectCollisions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l956"><span class="ln">956  </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l957"><span class="ln">957  </span></a>        this method calculates normal reaction force and friction. the reason it's here and not in 'boxCollision' is because resultant force from all other forces must be calculated first. 
<a name="l958"><span class="ln">958  </span></a> 
<a name="l959"><span class="ln">959  </span></a>        process: 
<a name="l960"><span class="ln">960  </span></a>            1. loop through all collisionRects and detect for collisions with solids. 
<a name="l961"><span class="ln">961  </span></a>            2) get the components of forces acting in the direction of the collision plane and add them to 'resultF', since that's what normal reaction force is. 
<a name="l962"><span class="ln">962  </span></a>                imagine this: you place a ball next to a perfectly straight-up wall on a perfectly flat surface on Earth. the wall won't push on it, since it's not pushing on the wall! 
<a name="l963"><span class="ln">963  </span></a>            3) if colliding with the right/left faces of a collisionRect, subtract 90 degrees (π/2 radians) from all angle calculations, since left/right is perpendicular to top/bottom. 
<a name="l964"><span class="ln">964  </span></a>            4) calculate the X and Y components of 'resultF' as the normal reaction force about X and Y. 
<a name="l965"><span class="ln">965  </span></a>                normal force about Z is an exception to this since collisionRects (currently) can't rotate about the Z-axis. 
<a name="l966"><span class="ln">966  </span></a> 
<a name="l967"><span class="ln">967  </span></a>            the maths and logic behind normal force calculations can be seen here: https://drive.google.com/file/d/1bkBZ3yYHVgOEAl8abxuTd2Ed1gnEsUrB/view?usp=sharing 
<a name="l968"><span class="ln">968  </span></a> 
<a name="l969"><span class="ln">969  </span></a>        note that all normalForce values will be multiplied by 0.999999 to compensate for floating point error, since it may otherwise return a normalForce value that's too high. 
<a name="l970"><span class="ln">970  </span></a>            higher normalForce than its actual value is a problem since it'll cause a point to accelerate off the surface (which violates Newton's 3rd law). thus, its value is lowered by 0.0001%. 
<a name="l971"><span class="ln">971  </span></a>        &quot;&quot;&quot;</span>
<a name="l972"><span class="ln">972  </span></a>        <span class="s2">for </span><span class="s1">crIdx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">)):</span>
<a name="l973"><span class="ln">973  </span></a>            <span class="s1">cr </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]  </span><span class="s0"># alias for current collisionRect</span>
<a name="l974"><span class="ln">974  </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollisionCalc</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] </span><span class="s2">and </span><span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'s'</span><span class="s3">):</span>
<a name="l975"><span class="ln">975  </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span>
<a name="l976"><span class="ln">976  </span></a>                    <span class="s1">cr</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">)  </span><span class="s0"># copy the collisionRect's angle to a private variable, so it can be changed (purely for the sake of calculations) without actually changing the collisionRect's stored 'angle' value</span>
<a name="l977"><span class="ln">977  </span></a>
<a name="l978"><span class="ln">978  </span></a>                <span class="s1">resultF </span><span class="s3">= </span><span class="s5">0</span>
<a name="l979"><span class="ln">979  </span></a>                <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'top'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'bottom'</span><span class="s3">):</span>
<a name="l980"><span class="ln">980  </span></a>                    <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span>
<a name="l981"><span class="ln">981  </span></a>                        <span class="s1">crIdx</span><span class="s3">]) &gt; </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># multiplier is used here to differentiate between top/bottom for the correct direction</span>
<a name="l982"><span class="ln">982  </span></a>                        <span class="s1">resultF </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l983"><span class="ln">983  </span></a>                    <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]) &lt; </span><span class="s5">0</span><span class="s3">:</span>
<a name="l984"><span class="ln">984  </span></a>                        <span class="s1">resultF </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l985"><span class="ln">985  </span></a>
<a name="l986"><span class="ln">986  </span></a>                <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'right'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'left'</span><span class="s3">):</span>
<a name="l987"><span class="ln">987  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] -= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l988"><span class="ln">988  </span></a>                    <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span>
<a name="l989"><span class="ln">989  </span></a>                        <span class="s1">crIdx</span><span class="s3">]) &lt; </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># multiplier is used here to differentiate between right/left for the correct direction</span>
<a name="l990"><span class="ln">990  </span></a>                        <span class="s1">resultF </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l991"><span class="ln">991  </span></a>                    <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]) &lt; </span><span class="s5">0</span><span class="s3">:</span>
<a name="l992"><span class="ln">992  </span></a>                        <span class="s1">resultF </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l993"><span class="ln">993  </span></a>
<a name="l994"><span class="ln">994  </span></a>                <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'front'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'back'</span><span class="s3">):</span>
<a name="l995"><span class="ln">995  </span></a>                    <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]) &lt; </span><span class="s5">0</span><span class="s3">:</span>
<a name="l996"><span class="ln">996  </span></a>                        <span class="s1">resultF </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__force</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l997"><span class="ln">997  </span></a>                    <span class="s0"># different code for front/back normal force and friction calcs since the Z angle of a collisionRect is always 0</span>
<a name="l998"><span class="ln">998  </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__normalForce</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s5">0.999999</span>
<a name="l999"><span class="ln">999  </span></a>                    <span class="s2">for </span><span class="s1">plane </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">2</span><span class="s3">):</span>
<a name="l1000"><span class="ln">1000 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction</span><span class="s3">[</span><span class="s1">plane</span><span class="s3">] = -</span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">plane</span><span class="s3">]) * </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span>
<a name="l1001"><span class="ln">1001 </span></a>                            <span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
<a name="l1002"><span class="ln">1002 </span></a>
<a name="l1003"><span class="ln">1003 </span></a>                <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] != </span><span class="s4">'front'</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] != </span><span class="s4">'back'</span><span class="s3">):</span>
<a name="l1004"><span class="ln">1004 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__normalForce</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = -</span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s5">0.999999</span>
<a name="l1005"><span class="ln">1005 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__normalForce</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s5">0.999999</span>
<a name="l1006"><span class="ln">1006 </span></a>                    <span class="s0"># negative coefficients used for friction here since it always acts in the opposite direction to motion</span>
<a name="l1007"><span class="ln">1007 </span></a>                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">== </span><span class="s4">'y'</span><span class="s3">:</span>
<a name="l1008"><span class="ln">1008 </span></a>                        <span class="s0"># negative coefficients used for normalForce here since it always acts in the opposite direction to resultant force</span>
<a name="l1009"><span class="ln">1009 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = -</span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) * </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span>
<a name="l1010"><span class="ln">1010 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>
<a name="l1011"><span class="ln">1011 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = -</span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span>
<a name="l1012"><span class="ln">1012 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>
<a name="l1013"><span class="ln">1013 </span></a>                    <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">== </span><span class="s4">'x'</span><span class="s3">:</span>
<a name="l1014"><span class="ln">1014 </span></a>                        <span class="s0"># no need for negative coefficients here since 'bAngle' will already be negative</span>
<a name="l1015"><span class="ln">1015 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) * </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span>
<a name="l1016"><span class="ln">1016 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1017"><span class="ln">1017 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">resultF </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span>
<a name="l1018"><span class="ln">1018 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__movingAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1019"><span class="ln">1019 </span></a>
<a name="l1020"><span class="ln">1020 </span></a>    <span class="s0"># check this out to see how I use lines, domains, and ranges for collision detection: https://drive.google.com/file/d/1a0McNZn3RdBdNACSEkrpEFIMrSON3MYZ/view?usp=sharing</span>
<a name="l1021"><span class="ln">1021 </span></a>    <span class="s0"># check this out to see how I get the formulae of the lines: https://drive.google.com/file/d/1xwD0r6H49mgiumBW7Ax1TiJFgu5GsMbu/view?usp=sharing</span>
<a name="l1022"><span class="ln">1022 </span></a>    <span class="s2">def </span><span class="s1">__yCollisionPlane</span><span class="s3">(</span><span class="s1">self</span><span class="s3">,</span>
<a name="l1023"><span class="ln">1023 </span></a>                          <span class="s1">b</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">:  </span><span class="s0"># find &quot;y&quot; from the mathematical formula: &quot;y = mx + c&quot; for each collision plane of a collisionRect</span>
<a name="l1024"><span class="ln">1024 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1025"><span class="ln">1025 </span></a>        :param b: collisionRect object. 
<a name="l1026"><span class="ln">1026 </span></a>        :return: dictionary of 'y' values for each collision plane's equation. 
<a name="l1027"><span class="ln">1027 </span></a> 
<a name="l1028"><span class="ln">1028 </span></a>        all 'b.vertex' values represent reference points on the collisionRect's vertices, so that y-intercept can be calculated. 
<a name="l1029"><span class="ln">1029 </span></a>        some reference points are repeated since multiple lines can share the same reference points. 
<a name="l1030"><span class="ln">1030 </span></a>            for example, 'left' and 'top' both intersect at the top-left vertex, so their x-coordinates are used for both lines. 
<a name="l1031"><span class="ln">1031 </span></a>        &quot;&quot;&quot;</span>
<a name="l1032"><span class="ln">1032 </span></a>        <span class="s2">return </span><span class="s3">{</span>
<a name="l1033"><span class="ln">1033 </span></a>            <span class="s4">'left'</span><span class="s3">: (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] - (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">])),</span>
<a name="l1034"><span class="ln">1034 </span></a>            <span class="s4">'right'</span><span class="s3">: (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] - (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">])),</span>
<a name="l1035"><span class="ln">1035 </span></a>            <span class="s4">'top'</span><span class="s3">: (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] - (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">])),</span>
<a name="l1036"><span class="ln">1036 </span></a>            <span class="s4">'bottom'</span><span class="s3">: (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] - (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">0</span><span class="s3">])),</span>
<a name="l1037"><span class="ln">1037 </span></a>        <span class="s3">}</span>
<a name="l1038"><span class="ln">1038 </span></a>
<a name="l1039"><span class="ln">1039 </span></a>    <span class="s2">def </span><span class="s1">__xCollisionPlane</span><span class="s3">(</span><span class="s1">self</span><span class="s3">,</span>
<a name="l1040"><span class="ln">1040 </span></a>                          <span class="s1">b</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">:  </span><span class="s0"># find &quot;x&quot; from the mathematical formula: &quot;x = my + c&quot; for each collision plane of a collisionRect</span>
<a name="l1041"><span class="ln">1041 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1042"><span class="ln">1042 </span></a>        :param b: collisionRect object. 
<a name="l1043"><span class="ln">1043 </span></a>        :return: dictionary of 'x' values for each collision plane's equation. 
<a name="l1044"><span class="ln">1044 </span></a> 
<a name="l1045"><span class="ln">1045 </span></a>        all 'b.vertex' values represent reference points on the collisionRect's vertices, so that x-intercept can be calculated. 
<a name="l1046"><span class="ln">1046 </span></a>        some reference points are repeated since multiple lines can share the same reference points. 
<a name="l1047"><span class="ln">1047 </span></a>            for example, 'left' and 'top' both intersect at the top-left vertex, so their y-coordinates are used for both lines. 
<a name="l1048"><span class="ln">1048 </span></a>        all values for 'b.grad' are swapped and negated since &quot;x = my + c&quot; is essentially the normal to &quot;y = mx + c&quot;. 
<a name="l1049"><span class="ln">1049 </span></a>            thus, gradient &quot;m&quot; must be negated and reciprocated, meaning m(X) = -(1 / m(Y)) and m(Y) = -(1 / m(X)). 
<a name="l1050"><span class="ln">1050 </span></a>        &quot;&quot;&quot;</span>
<a name="l1051"><span class="ln">1051 </span></a>        <span class="s2">return </span><span class="s3">{</span>
<a name="l1052"><span class="ln">1052 </span></a>            <span class="s4">'left'</span><span class="s3">: -(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">])),</span>
<a name="l1053"><span class="ln">1053 </span></a>            <span class="s4">'right'</span><span class="s3">: -(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">1</span><span class="s3">])),</span>
<a name="l1054"><span class="ln">1054 </span></a>            <span class="s4">'top'</span><span class="s3">: -(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">])),</span>
<a name="l1055"><span class="ln">1055 </span></a>            <span class="s4">'bottom'</span><span class="s3">: -(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] + (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">[</span><span class="s4">'y'</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]))</span>
<a name="l1056"><span class="ln">1056 </span></a>        <span class="s3">}</span>
<a name="l1057"><span class="ln">1057 </span></a>
<a name="l1058"><span class="ln">1058 </span></a>    <span class="s0"># detects and resolves collisions between spheres (points) and static cuboids (collision rects)</span>
<a name="l1059"><span class="ln">1059 </span></a>    <span class="s2">def </span><span class="s1">__boxCollision</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1060"><span class="ln">1060 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1061"><span class="ln">1061 </span></a>        this method is used to detect and resolve collisions between spheres (points) and static cuboids (collisionRects) using my own algorithm for AABB collision detection. 
<a name="l1062"><span class="ln">1062 </span></a> 
<a name="l1063"><span class="ln">1063 </span></a>        process: 
<a name="l1064"><span class="ln">1064 </span></a>            1. loop through all collisionRects. 
<a name="l1065"><span class="ln">1065 </span></a>            2. get the line equations for X and Y to enable plane collision detection. 
<a name="l1066"><span class="ln">1066 </span></a>                y = mx + c is used for smaller values of bAngle (&lt;=45°) since gradient m will always be &lt;=1 (since tan(45) = 1). 
<a name="l1067"><span class="ln">1067 </span></a>                x = my + c is used for larger values of bAngle (&gt;45°) since tan(bAngle) will get extremely large, causing large uncertainties in floating point precision. 
<a name="l1068"><span class="ln">1068 </span></a>                    if this is not used, large value for bAngle (on the colliding plane) will cause colliding points to skyrocket instantly due to extremely large values of gradient m. 
<a name="l1069"><span class="ln">1069 </span></a>            3. if a point is: 
<a name="l1070"><span class="ln">1070 </span></a>                a) intersecting a collisionRect with a large tolerance 'collisionCalcTolerance', apply normal reaction force and friction. 
<a name="l1071"><span class="ln">1071 </span></a>                b) intersecting a collisionRect with a small tolerance collisionTolerance, teleport the point to the collisionRect’s surface to apply an impulse. 
<a name="l1072"><span class="ln">1072 </span></a>                c) fully within a collisionRect with a small tolerance 'collisionTolerance', apply liquid physics if the collisionRect is a liquid. 
<a name="l1073"><span class="ln">1073 </span></a>                detection is done using domains/ranges of lines: https://drive.google.com/file/d/1a0McNZn3RdBdNACSEkrpEFIMrSON3MYZ/view?usp=sharing 
<a name="l1074"><span class="ln">1074 </span></a>                these tolerances are used to compensate for floating point error. 
<a name="l1075"><span class="ln">1075 </span></a>                if not used, collisions will be detected every other frame rather than every frame even if a point visually slides down a surface. 
<a name="l1076"><span class="ln">1076 </span></a>                this is a problem since the point will experience an impulse nearly every frame rather than just once when colliding with a collisionRect. 
<a name="l1077"><span class="ln">1077 </span></a>                    if elasticity &gt;= 1, the point would accelerate every other frame (speed up infinitely). 
<a name="l1078"><span class="ln">1078 </span></a>                    if elasticity &lt; 1, the point would decelerate every other frame (slow down infinitely). 
<a name="l1079"><span class="ln">1079 </span></a>                    both of these outcomes would occur due floating point error in trig functions and position values. 
<a name="l1080"><span class="ln">1080 </span></a>                check out this link to see some examples: https://drive.google.com/file/d/1i6ZdYdIu9J1fGjqJSI3Ou5GV-YMcyKag/view?usp=sharing 
<a name="l1081"><span class="ln">1081 </span></a>            4. if the point is in front of a collisionRect's edge, store that edge's axis (ignoring the collisionRect's orientation) in 'vertexState'. 
<a name="l1082"><span class="ln">1082 </span></a>                vertexState will be used to fetch the indexes of the grouped vertices depending on its axis. 
<a name="l1083"><span class="ln">1083 </span></a>                    here's why this must be done: https://drive.google.com/file/d/1llq6UTfJHZ2GJic5s8510RJoKKEBbg1Y/view?usp=sharing 
<a name="l1084"><span class="ln">1084 </span></a>                ultimately, this will allow a point to determine the 2 closest vertices of each collisionRect to the point to allow for edge collision detection. 
<a name="l1085"><span class="ln">1085 </span></a>                here's how 'vertexState' is determined: https://drive.google.com/file/d/1B-GqxPcpGkWAE_ogzMvYntTNmt8R99gT/view?usp=drive_link, https://drive.google.com/file/d/1PQrnfejqzLJlD6GdVNaNNZzTivElZJHb/view?usp=sharing 
<a name="l1086"><span class="ln">1086 </span></a>                    here's a 2D-ish visualization of this: https://drive.google.com/file/d/1Ne9uYwj5Y1x832fyxHiSnWMDw0zEPRHm/view?usp=sharing, https://drive.google.com/file/d/1dtp28rJAdf8S78__yX-8-ykr1pub44e5/view?usp=sharing 
<a name="l1087"><span class="ln">1087 </span></a>            5. if the point is in front of a plane, set 'lastCollision' to the plane it's in front of. also factors in the point's radius. 
<a name="l1088"><span class="ln">1088 </span></a>                this value never resets in order to allow for accurate liquid physics calculations, since being submerged within a collisionRect causes the point to be behind all the collisionRect’s planes. 
<a name="l1089"><span class="ln">1089 </span></a>                radius is added when the plane is 'right'/'top'/'front', since those planes face the positive x/y/z axes (respectively). 
<a name="l1090"><span class="ln">1090 </span></a>                radius is subtracted when the plane is 'left'/'bottom'/'back', since those planes face the negative x/y/z axes (respectively). 
<a name="l1091"><span class="ln">1091 </span></a>            6. if the point's CENTER is in front of a plane, set 'collision' to the plane it's in front of. 
<a name="l1092"><span class="ln">1092 </span></a>                unlike 'lastCollision', this value resets if the point isn't in front of a plane anymore. 
<a name="l1093"><span class="ln">1093 </span></a>                'collision' is used to get what plane a point is currently in front of, so that the appropriate calculations for collision resolution can be applied, e.g.: 
<a name="l1094"><span class="ln">1094 </span></a>                    whether to use y = mx + c OR x = my + c, direction of resultant and normal reaction forces, direction &amp; magnitude of impulse. 
<a name="l1095"><span class="ln">1095 </span></a>            7. determine a value for 'multiplier' to get the direction in which the point should be displaced when colliding with a collisionRect’s plane. 
<a name="l1096"><span class="ln">1096 </span></a>                check this out to see how and why this is done: https://drive.google.com/file/d/1Gpy3J38fYBKXRfSFU2cz9M1vn91dDYWK/view?usp=drive_link 
<a name="l1097"><span class="ln">1097 </span></a>            see below for point 8 onwards. 
<a name="l1098"><span class="ln">1098 </span></a>        &quot;&quot;&quot;</span>
<a name="l1099"><span class="ln">1099 </span></a>        <span class="s1">cubeCollision </span><span class="s3">= </span><span class="s2">False</span>
<a name="l1100"><span class="ln">1100 </span></a>        <span class="s2">for </span><span class="s1">crIdx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">)):</span>
<a name="l1101"><span class="ln">1101 </span></a>            <span class="s1">cr </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]  </span><span class="s0"># alias for current collisionRect</span>
<a name="l1102"><span class="ln">1102 </span></a>
<a name="l1103"><span class="ln">1103 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span>
<a name="l1104"><span class="ln">1104 </span></a>                <span class="s1">cr</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">)  </span><span class="s0"># assign collisionRect angle to a private variable, so it can be changed (for the sake of calculation) without actually changing the collisionRect's angle</span>
<a name="l1105"><span class="ln">1105 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionPlane</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">)</span>
<a name="l1106"><span class="ln">1106 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__xCollisionLine </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__xCollisionPlane</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">)</span>
<a name="l1107"><span class="ln">1107 </span></a>
<a name="l1108"><span class="ln">1108 </span></a>            <span class="s0"># aliasing variables for increased readability</span>
<a name="l1109"><span class="ln">1109 </span></a>            <span class="s1">topY </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s4">'top'</span><span class="s3">]</span>
<a name="l1110"><span class="ln">1110 </span></a>            <span class="s1">bottomY </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s4">'bottom'</span><span class="s3">]</span>
<a name="l1111"><span class="ln">1111 </span></a>            <span class="s1">rightY </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s4">'right'</span><span class="s3">]</span>
<a name="l1112"><span class="ln">1112 </span></a>            <span class="s1">leftY </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s4">'left'</span><span class="s3">]</span>
<a name="l1113"><span class="ln">1113 </span></a>            <span class="s1">radOffsetCos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l1114"><span class="ln">1114 </span></a>            <span class="s1">radOffsetSin </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l1115"><span class="ln">1115 </span></a>
<a name="l1116"><span class="ln">1116 </span></a>            <span class="s0"># it's appropriate to use y = mx + c for collision detection here (even for large angles) since floating point error has negligible effect on detection</span>
<a name="l1117"><span class="ln">1117 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollisionCalc</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">collisionCalcTolerance </span><span class="s3">+ </span><span class="s1">topY </span><span class="s3">+ </span><span class="s1">radOffsetCos</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1118"><span class="ln">1118 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (-</span><span class="s1">collisionCalcTolerance </span><span class="s3">+ </span><span class="s1">bottomY </span><span class="s3">- </span><span class="s1">radOffsetCos</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span>
<a name="l1119"><span class="ln">1119 </span></a>                        <span class="s1">collisionCalcTolerance </span><span class="s3">+ </span><span class="s1">rightY </span><span class="s3">+ </span><span class="s1">radOffsetSin</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span>
<a name="l1120"><span class="ln">1120 </span></a>                        <span class="s3">-</span><span class="s1">collisionCalcTolerance </span><span class="s3">+ </span><span class="s1">leftY </span><span class="s3">- </span><span class="s1">radOffsetSin</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1121"><span class="ln">1121 </span></a>                                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span>
<a name="l1122"><span class="ln">1122 </span></a>                                                        <span class="s1">collisionCalcTolerance </span><span class="s3">+ </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1123"><span class="ln">1123 </span></a>                                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (-</span><span class="s1">collisionCalcTolerance </span><span class="s3">+ </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span>
<a name="l1124"><span class="ln">1124 </span></a>                                                    <span class="s4">'back'</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">))  </span><span class="s0"># True if any part of the point is inside a collisionRect, given a collisionCalcTolerance</span>
<a name="l1125"><span class="ln">1125 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">topY </span><span class="s3">+ </span><span class="s1">radOffsetCos</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1126"><span class="ln">1126 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (-</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">bottomY </span><span class="s3">- </span><span class="s1">radOffsetCos</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1127"><span class="ln">1127 </span></a>                                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">rightY </span><span class="s3">+ </span><span class="s1">radOffsetSin</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1128"><span class="ln">1128 </span></a>                                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (-</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">leftY </span><span class="s3">- </span><span class="s1">radOffsetSin</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1129"><span class="ln">1129 </span></a>                                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span>
<a name="l1130"><span class="ln">1130 </span></a>                                                        <span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1131"><span class="ln">1131 </span></a>                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (-</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span>
<a name="l1132"><span class="ln">1132 </span></a>                                            <span class="s4">'back'</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">))  </span><span class="s0"># True if any part of the point is inside a collisionRect, given a collisionTolerance</span>
<a name="l1133"><span class="ln">1133 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cubeSubmersion</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">topY </span><span class="s3">- </span><span class="s1">radOffsetCos</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1134"><span class="ln">1134 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (-</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">bottomY </span><span class="s3">+ </span><span class="s1">radOffsetCos</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span>
<a name="l1135"><span class="ln">1135 </span></a>                        <span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">rightY </span><span class="s3">- </span><span class="s1">radOffsetSin</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span>
<a name="l1136"><span class="ln">1136 </span></a>                        <span class="s3">-</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">leftY </span><span class="s3">+ </span><span class="s1">radOffsetSin</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span>
<a name="l1137"><span class="ln">1137 </span></a>                        <span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1138"><span class="ln">1138 </span></a>                                                 <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (-</span><span class="s1">collisionTolerance </span><span class="s3">+ </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span>
<a name="l1139"><span class="ln">1139 </span></a>                                             <span class="s4">'back'</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">))  </span><span class="s0"># cubeCollision but with reversed radii calcs, since this is cubeSUBMERSION after all!</span>
<a name="l1140"><span class="ln">1140 </span></a>
<a name="l1141"><span class="ln">1141 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">= </span><span class="s4">''  </span><span class="s0"># stores the facing axis of the nearest vertex</span>
<a name="l1142"><span class="ln">1142 </span></a>            <span class="s2">if </span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">rightY</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt; </span><span class="s1">leftY</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1143"><span class="ln">1143 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">topY</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt; </span><span class="s1">bottomY</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1144"><span class="ln">1144 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">]) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1145"><span class="ln">1145 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">])):  </span><span class="s0"># x &gt; right, x &lt; left, y &gt; top, y &lt; bottom, back &lt; z &lt; front</span>
<a name="l1146"><span class="ln">1146 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">= </span><span class="s4">'z'</span>
<a name="l1147"><span class="ln">1147 </span></a>            <span class="s2">elif </span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">rightY</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt; </span><span class="s1">leftY</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1148"><span class="ln">1148 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">topY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">bottomY</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1149"><span class="ln">1149 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt; </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">]) </span><span class="s2">or </span><span class="s3">(</span>
<a name="l1150"><span class="ln">1150 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt; </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">])):  </span><span class="s0"># x &gt; right, x &lt; left, bottom &lt; y &lt; top, z &gt; front, z &lt; back</span>
<a name="l1151"><span class="ln">1151 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">= </span><span class="s4">'y'</span>
<a name="l1152"><span class="ln">1152 </span></a>            <span class="s2">elif </span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">rightY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">leftY</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1153"><span class="ln">1153 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">topY</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt; </span><span class="s1">bottomY</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1154"><span class="ln">1154 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt; </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">]) </span><span class="s2">or </span><span class="s3">(</span>
<a name="l1155"><span class="ln">1155 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt; </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">])):  </span><span class="s0"># left &lt; x &lt; right, y &gt; top, y &lt; bottom, z &gt; front, z &lt; back</span>
<a name="l1156"><span class="ln">1156 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">= </span><span class="s4">'x'</span>
<a name="l1157"><span class="ln">1157 </span></a>
<a name="l1158"><span class="ln">1158 </span></a>            <span class="s0"># self.lastCollision represents the surface of a collision cuboid that the point was LAST in front of, factoring in its radius as well. this value never resets.</span>
<a name="l1159"><span class="ln">1159 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">rightY </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span><span class="s1">leftY </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1160"><span class="ln">1160 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1161"><span class="ln">1161 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)):</span>
<a name="l1162"><span class="ln">1162 </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span><span class="s1">topY </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">):</span>
<a name="l1163"><span class="ln">1163 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'top'</span>
<a name="l1164"><span class="ln">1164 </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">bottomY </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">):</span>
<a name="l1165"><span class="ln">1165 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'bottom'</span>
<a name="l1166"><span class="ln">1166 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">topY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">bottomY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">]) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1167"><span class="ln">1167 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">]):</span>
<a name="l1168"><span class="ln">1168 </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span><span class="s1">rightY </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">):</span>
<a name="l1169"><span class="ln">1169 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'right'</span>
<a name="l1170"><span class="ln">1170 </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">leftY </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">):</span>
<a name="l1171"><span class="ln">1171 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'left'</span>
<a name="l1172"><span class="ln">1172 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">topY </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span><span class="s1">bottomY </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1173"><span class="ln">1173 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= (</span><span class="s1">rightY </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= (</span><span class="s1">leftY </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)):</span>
<a name="l1174"><span class="ln">1174 </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">):</span>
<a name="l1175"><span class="ln">1175 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'front'</span>
<a name="l1176"><span class="ln">1176 </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">):</span>
<a name="l1177"><span class="ln">1177 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'back'</span>
<a name="l1178"><span class="ln">1178 </span></a>
<a name="l1179"><span class="ln">1179 </span></a>            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:  </span><span class="s0"># causes self.collision[crIdx] to reset when not in front of a plane</span>
<a name="l1180"><span class="ln">1180 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">''</span>
<a name="l1181"><span class="ln">1181 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">rightY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">leftY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">])) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1182"><span class="ln">1182 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">])):</span>
<a name="l1183"><span class="ln">1183 </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">topY</span><span class="s3">:</span>
<a name="l1184"><span class="ln">1184 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'top'</span>
<a name="l1185"><span class="ln">1185 </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">bottomY</span><span class="s3">:</span>
<a name="l1186"><span class="ln">1186 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'bottom'</span>
<a name="l1187"><span class="ln">1187 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">topY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">bottomY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">]) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1188"><span class="ln">1188 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">]):</span>
<a name="l1189"><span class="ln">1189 </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">rightY</span><span class="s3">:</span>
<a name="l1190"><span class="ln">1190 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'right'</span>
<a name="l1191"><span class="ln">1191 </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">leftY</span><span class="s3">:</span>
<a name="l1192"><span class="ln">1192 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'left'</span>
<a name="l1193"><span class="ln">1193 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">topY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">bottomY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt;= </span><span class="s1">rightY</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1194"><span class="ln">1194 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &gt;= </span><span class="s1">leftY</span><span class="s3">):</span>
<a name="l1195"><span class="ln">1195 </span></a>                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">]):</span>
<a name="l1196"><span class="ln">1196 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'front'</span>
<a name="l1197"><span class="ln">1197 </span></a>                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &lt;= (</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">]):</span>
<a name="l1198"><span class="ln">1198 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s4">'back'</span>
<a name="l1199"><span class="ln">1199 </span></a>
<a name="l1200"><span class="ln">1200 </span></a>            <span class="s0"># get the distance until edge/vertex collision</span>
<a name="l1201"><span class="ln">1201 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">''</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span>
<a name="l1202"><span class="ln">1202 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">):  </span><span class="s0"># &quot;why should we resolve vertex/edge collisions if the point is in front of a face on the collision rect?&quot; hence, this if statement is used to optimize performance.</span>
<a name="l1203"><span class="ln">1203 </span></a>                <span class="s1">minDist</span><span class="s3">, </span><span class="s1">vertexIdx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__getVertexDist</span><span class="s3">(</span>
<a name="l1204"><span class="ln">1204 </span></a>                    <span class="s1">cr</span><span class="s3">)  </span><span class="s0"># get the distance to a vertex/edge collision as well as the index of the vertex/vertices, respectively</span>
<a name="l1205"><span class="ln">1205 </span></a>
<a name="l1206"><span class="ln">1206 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'right'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'top'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span>
<a name="l1207"><span class="ln">1207 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lastCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'front'</span><span class="s3">):</span>
<a name="l1208"><span class="ln">1208 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s5">1</span>
<a name="l1209"><span class="ln">1209 </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l1210"><span class="ln">1210 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span>
<a name="l1211"><span class="ln">1211 </span></a>                    <span class="s1">crIdx</span><span class="s3">] = -</span><span class="s5">1  </span><span class="s0"># radius displacement is reversed for left, bottom, and back since they face the negative x/y/z axes, respectively</span>
<a name="l1212"><span class="ln">1212 </span></a>
<a name="l1213"><span class="ln">1213 </span></a>            <span class="s4">&quot;&quot;&quot; 
<a name="l1214"><span class="ln">1214 </span></a>            8. detect collisions between points and planes: 
<a name="l1215"><span class="ln">1215 </span></a>                if the point is in front of a plane (vertexState == '' and collision != '') AND a collisionRect is being collided with (cubeCollisionCalc is True). 
<a name="l1216"><span class="ln">1216 </span></a>            9. detect collisions between points and edges: 
<a name="l1217"><span class="ln">1217 </span></a>                if the point is in front of an edge (vertexState != '') AND https://drive.google.com/file/d/14ooXx_oDUzhqFVb1EDGZTB3ShXxDIFNU/view?usp=sharing AND the collisionRect is a solid (cr.type == 's'). 
<a name="l1218"><span class="ln">1218 </span></a>            10. detect collisions between points and vertices: 
<a name="l1219"><span class="ln">1219 </span></a>                if the point's distance to the nearest vertex is ever less than its radius. 
<a name="l1220"><span class="ln">1220 </span></a>            11. if steps 8, 9, and 10 are all False, reset 'colliding' to False so that an impulse can be applied on the next collision. 
<a name="l1221"><span class="ln">1221 </span></a>            12. if the point isn't colliding with any collisionRect, reset all values that depend on undergoing a solid/liquid collision to 0. 
<a name="l1222"><span class="ln">1222 </span></a>            &quot;&quot;&quot;</span>
<a name="l1223"><span class="ln">1223 </span></a>
<a name="l1224"><span class="ln">1224 </span></a>            <span class="s0"># detect collisions between points and planes (flat surfaces) on a collision rect (cuboid)</span>
<a name="l1225"><span class="ln">1225 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">== </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] != </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollisionCalc</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:</span>
<a name="l1226"><span class="ln">1226 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__planeCollision</span><span class="s3">(</span><span class="s1">crIdx</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">)</span>
<a name="l1227"><span class="ln">1227 </span></a>
<a name="l1228"><span class="ln">1228 </span></a>            <span class="s0"># detect collisions between points and edges on a SOLID collision rect (cuboid)</span>
<a name="l1229"><span class="ln">1229 </span></a>            <span class="s0"># see the 'getVertexDist' method for the logic behind 'minDist'</span>
<a name="l1230"><span class="ln">1230 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1231"><span class="ln">1231 </span></a>                    <span class="s1">minDist </span><span class="s3">&lt;= (</span><span class="s1">distance</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s1">vertexIdx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]], </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s1">vertexIdx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]]))) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'s'</span><span class="s3">):</span>
<a name="l1232"><span class="ln">1232 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span>
<a name="l1233"><span class="ln">1233 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">)  </span><span class="s0"># freeze the point (since incomplete edge collision resolution implementation)</span>
<a name="l1234"><span class="ln">1234 </span></a>
<a name="l1235"><span class="ln">1235 </span></a>            <span class="s0"># detect collisions between points and vertices (corners) on a SOLID collision rect (cuboid)</span>
<a name="l1236"><span class="ln">1236 </span></a>            <span class="s0"># see the 'getVertexDist' method for the logic behind 'cr.vertex[vertexIdx]' (closest vertex to the point at index 'vertexIdx')</span>
<a name="l1237"><span class="ln">1237 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">== </span><span class="s4">''</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1238"><span class="ln">1238 </span></a>                    <span class="s1">distance</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s1">vertexIdx</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">) &lt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'s'</span><span class="s3">):</span>
<a name="l1239"><span class="ln">1239 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span>
<a name="l1240"><span class="ln">1240 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">)  </span><span class="s0"># freeze the point (since incomplete vertex collision resolution implementation)</span>
<a name="l1241"><span class="ln">1241 </span></a>
<a name="l1242"><span class="ln">1242 </span></a>            <span class="s0"># if none of the cases above are True, then the point isn't colliding with any collisionRect</span>
<a name="l1243"><span class="ln">1243 </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l1244"><span class="ln">1244 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s2">False</span>
<a name="l1245"><span class="ln">1245 </span></a>
<a name="l1246"><span class="ln">1246 </span></a>            <span class="s1">cubeCollision </span><span class="s3">= </span><span class="s1">cubeCollision </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollisionCalc</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]  </span><span class="s0"># True if cubeCollisionCalc is ever True</span>
<a name="l1247"><span class="ln">1247 </span></a>
<a name="l1248"><span class="ln">1248 </span></a>        <span class="s2">if not </span><span class="s1">cubeCollision</span><span class="s3">:  </span><span class="s0"># reset values that depend on a solid/liquid cube collision when not colliding with ANY collisionRect</span>
<a name="l1249"><span class="ln">1249 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__normalForce </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1250"><span class="ln">1250 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__friction </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1251"><span class="ln">1251 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1252"><span class="ln">1252 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidUpthrust </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1253"><span class="ln">1253 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidDrag </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1254"><span class="ln">1254 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume </span><span class="s3">= </span><span class="s5">0</span>
<a name="l1255"><span class="ln">1255 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedArea </span><span class="s3">= </span><span class="s5">0</span>
<a name="l1256"><span class="ln">1256 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedRadius </span><span class="s3">= </span><span class="s5">0</span>
<a name="l1257"><span class="ln">1257 </span></a>
<a name="l1258"><span class="ln">1258 </span></a>    <span class="s2">def </span><span class="s1">__getVertexDist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s3">(</span><span class="s1">int</span><span class="s3">, (</span><span class="s1">list </span><span class="s2">or </span><span class="s1">int</span><span class="s3">)):</span>
<a name="l1259"><span class="ln">1259 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1260"><span class="ln">1260 </span></a>        :param cr: current collisionRect object. 
<a name="l1261"><span class="ln">1261 </span></a>        :return: minimum distance to the nearest vertex, and the index(es) of the nearest vertex(es) 
<a name="l1262"><span class="ln">1262 </span></a> 
<a name="l1263"><span class="ln">1263 </span></a>        this method is used to get the distance and index(es) to the nearest vertex(es), which will be used for vertex/edge collision detection. 
<a name="l1264"><span class="ln">1264 </span></a>        due to this method's highly mathematical approach, all comments will be in-line for increased readability. 
<a name="l1265"><span class="ln">1265 </span></a>        &quot;&quot;&quot;</span>
<a name="l1266"><span class="ln">1266 </span></a>        <span class="s1">vertexDist </span><span class="s3">= []  </span><span class="s0"># distance to each edge/vertex, depending on the type of collision</span>
<a name="l1267"><span class="ln">1267 </span></a>        <span class="s1">vIdx </span><span class="s3">= []  </span><span class="s0"># stores (specific) index values in a specific order from the collisionRect.vertex list</span>
<a name="l1268"><span class="ln">1268 </span></a>        <span class="s1">vertexIdx </span><span class="s3">= []  </span><span class="s0"># stores index of closest vertex indexes</span>
<a name="l1269"><span class="ln">1269 </span></a>        <span class="s1">minDist </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s4">'inf'</span><span class="s3">)  </span><span class="s0"># context of value changes depending on type of collision</span>
<a name="l1270"><span class="ln">1270 </span></a>
<a name="l1271"><span class="ln">1271 </span></a>        <span class="s0"># group vertices based on 'vertexState' because of this: https://drive.google.com/file/d/1llq6UTfJHZ2GJic5s8510RJoKKEBbg1Y/view?usp=drive_link</span>
<a name="l1272"><span class="ln">1272 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">== </span><span class="s4">'x'</span><span class="s3">:</span>
<a name="l1273"><span class="ln">1273 </span></a>            <span class="s1">vIdx </span><span class="s3">= [[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">7</span><span class="s3">], [</span><span class="s5">3</span><span class="s3">, </span><span class="s5">6</span><span class="s3">], [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">]]</span>
<a name="l1274"><span class="ln">1274 </span></a>        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">== </span><span class="s4">'y'</span><span class="s3">:</span>
<a name="l1275"><span class="ln">1275 </span></a>            <span class="s1">vIdx </span><span class="s3">= [[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">7</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">]]</span>
<a name="l1276"><span class="ln">1276 </span></a>        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">== </span><span class="s4">'z'</span><span class="s3">:</span>
<a name="l1277"><span class="ln">1277 </span></a>            <span class="s1">vIdx </span><span class="s3">= [[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">5</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">], [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">]]</span>
<a name="l1278"><span class="ln">1278 </span></a>        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># when undergoing a corner collision, don't group vertices (since only the nearest vertex is relevant)</span>
<a name="l1279"><span class="ln">1279 </span></a>            <span class="s2">for </span><span class="s1">inc </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">8</span><span class="s3">):</span>
<a name="l1280"><span class="ln">1280 </span></a>                <span class="s1">vIdx</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inc</span><span class="s3">)</span>
<a name="l1281"><span class="ln">1281 </span></a>
<a name="l1282"><span class="ln">1282 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexState </span><span class="s3">!= </span><span class="s4">''</span><span class="s3">:  </span><span class="s0"># edge collision detection</span>
<a name="l1283"><span class="ln">1283 </span></a>            <span class="s1">dist </span><span class="s3">= []  </span><span class="s0"># distance to each vertex as indicated by vIdx</span>
<a name="l1284"><span class="ln">1284 </span></a>            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">vIdx</span><span class="s3">)):</span>
<a name="l1285"><span class="ln">1285 </span></a>                <span class="s1">dist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([])</span>
<a name="l1286"><span class="ln">1286 </span></a>                <span class="s1">vertexDist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
<a name="l1287"><span class="ln">1287 </span></a>                <span class="s2">for </span><span class="s1">h </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">vIdx</span><span class="s3">[</span><span class="s1">d</span><span class="s3">])):</span>
<a name="l1288"><span class="ln">1288 </span></a>                    <span class="s1">tempDist </span><span class="s3">= </span><span class="s1">distance</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s1">vIdx</span><span class="s3">[</span><span class="s1">d</span><span class="s3">][</span><span class="s1">h</span><span class="s3">]],</span>
<a name="l1289"><span class="ln">1289 </span></a>                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)  </span><span class="s0"># value of d1 when h == 0, and d2 when h == 1</span>
<a name="l1290"><span class="ln">1290 </span></a>                    <span class="s2">if </span><span class="s1">tempDist </span><span class="s3">&gt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">:  </span><span class="s0"># used to prevent sqrt(-number)</span>
<a name="l1291"><span class="ln">1291 </span></a>                        <span class="s0"># check out the maths &amp; logic for this here: https://drive.google.com/file/d/14ooXx_oDUzhqFVb1EDGZTB3ShXxDIFNU/view?usp=sharing (edge-collision-detection.JPG)</span>
<a name="l1292"><span class="ln">1292 </span></a>                        <span class="s1">dist</span><span class="s3">[</span><span class="s1">d</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span>
<a name="l1293"><span class="ln">1293 </span></a>                            <span class="s1">tempDist </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">2</span><span class="s3">))  </span><span class="s0"># gets the distance from each vertex to the current sphere's position (value of v1/v2 from edge-collision-detection.JPG)</span>
<a name="l1294"><span class="ln">1294 </span></a>                        <span class="s1">vertexDist</span><span class="s3">[</span><span class="s1">d</span><span class="s3">] += </span><span class="s1">dist</span><span class="s3">[</span><span class="s1">d</span><span class="s3">][</span>
<a name="l1295"><span class="ln">1295 </span></a>                            <span class="s1">h</span><span class="s3">]  </span><span class="s0"># sum of v1 and v2 as seen in edge-collision-detection.JPG, where dist[d][0] = v1 and dist[d][1] = v2</span>
<a name="l1296"><span class="ln">1296 </span></a>                    <span class="s2">else</span><span class="s3">:  </span><span class="s0"># if tempDist &lt; radius, then a collision is happening</span>
<a name="l1297"><span class="ln">1297 </span></a>                        <span class="s1">dist</span><span class="s3">[</span><span class="s1">d</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
<a name="l1298"><span class="ln">1298 </span></a>        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># vertex (corner) collision detection</span>
<a name="l1299"><span class="ln">1299 </span></a>            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">:</span>
<a name="l1300"><span class="ln">1300 </span></a>                <span class="s1">vertexDist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">distance</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">))</span>
<a name="l1301"><span class="ln">1301 </span></a>
<a name="l1302"><span class="ln">1302 </span></a>        <span class="s0"># get the closest vertex to the point</span>
<a name="l1303"><span class="ln">1303 </span></a>        <span class="s2">for </span><span class="s1">ve </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">vertexDist</span><span class="s3">)):</span>
<a name="l1304"><span class="ln">1304 </span></a>            <span class="s2">if </span><span class="s1">vertexDist</span><span class="s3">[</span><span class="s1">ve</span><span class="s3">] &lt; </span><span class="s1">minDist</span><span class="s3">:</span>
<a name="l1305"><span class="ln">1305 </span></a>                <span class="s1">minDist </span><span class="s3">= </span><span class="s1">vertexDist</span><span class="s3">[</span>
<a name="l1306"><span class="ln">1306 </span></a>                    <span class="s1">ve</span><span class="s3">]  </span><span class="s0"># get the new smallest value of calculated v1 + v2 (if edge) OR distance to the new closest vertex (if vertex)</span>
<a name="l1307"><span class="ln">1307 </span></a>                <span class="s1">vertexIdx </span><span class="s3">= </span><span class="s1">vIdx</span><span class="s3">[</span><span class="s1">ve</span><span class="s3">]  </span><span class="s0"># get the index(ex) of the new closest vertex(es)</span>
<a name="l1308"><span class="ln">1308 </span></a>
<a name="l1309"><span class="ln">1309 </span></a>        <span class="s2">return </span><span class="s1">minDist</span><span class="s3">, </span><span class="s1">vertexIdx</span>
<a name="l1310"><span class="ln">1310 </span></a>
<a name="l1311"><span class="ln">1311 </span></a>    <span class="s2">def </span><span class="s1">__planeCollision</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">crIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1312"><span class="ln">1312 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1313"><span class="ln">1313 </span></a>        :param crIdx: index position of the colliding collisionRect. 
<a name="l1314"><span class="ln">1314 </span></a>        :param cr: colliding collisionRect object. 
<a name="l1315"><span class="ln">1315 </span></a>        &quot;&quot;&quot;</span>
<a name="l1316"><span class="ln">1316 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'right'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'left'</span><span class="s3">):</span>
<a name="l1317"><span class="ln">1317 </span></a>            <span class="s0"># shift angle by 90° since perpendicular surfaces to the collision rect (left &amp; right) are, well... perpendicular (to top &amp; bottom)</span>
<a name="l1318"><span class="ln">1318 </span></a>            <span class="s0"># angle is subtracted since all movement is reversed since it's, well... perpendicular</span>
<a name="l1319"><span class="ln">1319 </span></a>            <span class="s0"># this also makes dealing with gradients easier (I only have to get magnitude of gradient, not whether it's positive or negative)</span>
<a name="l1320"><span class="ln">1320 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] -= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l1321"><span class="ln">1321 </span></a>
<a name="l1322"><span class="ln">1322 </span></a>        <span class="s0"># determine whether to use y = mx + c or x = my + c based on the size of bAngle in order to keep the size of gradient m less than or equal to 1</span>
<a name="l1323"><span class="ln">1323 </span></a>        <span class="s0"># if gradient m is too large (m &gt; 1) for y = mx + c, use x = my + c instead for a smaller gradient m (m &lt;= 1), increasing floating point precision</span>
<a name="l1324"><span class="ln">1324 </span></a>        <span class="s0"># check out this link to see the logic behind this: https://drive.google.com/file/d/1s67QaMXnC3LGD11jn75S9DDp1HxjND_O/view?usp=sharing</span>
<a name="l1325"><span class="ln">1325 </span></a>        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])) &lt;= </span><span class="s5">45</span><span class="s3">:</span>
<a name="l1326"><span class="ln">1326 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">= </span><span class="s4">'y'</span>
<a name="l1327"><span class="ln">1327 </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l1328"><span class="ln">1328 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">= </span><span class="s4">'x'</span>
<a name="l1329"><span class="ln">1329 </span></a>
<a name="l1330"><span class="ln">1330 </span></a>        <span class="s0"># determine which type of collision calculations to use depending on if the collisionRect is a solid or liquid</span>
<a name="l1331"><span class="ln">1331 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cubeCollision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:</span>
<a name="l1332"><span class="ln">1332 </span></a>            <span class="s2">if </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'s'</span><span class="s3">:</span>
<a name="l1333"><span class="ln">1333 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__planeCollisionSolid</span><span class="s3">(</span><span class="s1">crIdx</span><span class="s3">)</span>
<a name="l1334"><span class="ln">1334 </span></a>            <span class="s2">elif </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'l'</span><span class="s3">:</span>
<a name="l1335"><span class="ln">1335 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__planeCollisionLiquid</span><span class="s3">(</span><span class="s1">crIdx</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">)</span>
<a name="l1336"><span class="ln">1336 </span></a>
<a name="l1337"><span class="ln">1337 </span></a>    <span class="s2">def </span><span class="s1">__planeCollisionLiquid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">crIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1338"><span class="ln">1338 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1339"><span class="ln">1339 </span></a>        :param crIdx: index position of the colliding collisionRect. 
<a name="l1340"><span class="ln">1340 </span></a>        :param cr: colliding collisionRect object. 
<a name="l1341"><span class="ln">1341 </span></a>        &quot;&quot;&quot;</span>
<a name="l1342"><span class="ln">1342 </span></a>        <span class="s1">submergedAmt </span><span class="s3">= </span><span class="s5">0</span>
<a name="l1343"><span class="ln">1343 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'front'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'back'</span><span class="s3">):</span>
<a name="l1344"><span class="ln">1344 </span></a>            <span class="s1">submergedAmt </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span>
<a name="l1345"><span class="ln">1345 </span></a>                <span class="s3">(</span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">) - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1346"><span class="ln">1346 </span></a>        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">== </span><span class="s4">'y'</span><span class="s3">:</span>
<a name="l1347"><span class="ln">1347 </span></a>            <span class="s1">submergedAmt </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">+ (</span>
<a name="l1348"><span class="ln">1348 </span></a>                        <span class="s3">-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]]) * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span>
<a name="l1349"><span class="ln">1349 </span></a>                                                                                                 <span class="s5">2</span><span class="s3">]))  </span><span class="s0"># check out the maths for this here: https://drive.google.com/file/d/1aLbunKXn89LqLVKGvRz2rTGpkQcK_hSD/view?usp=drive_link</span>
<a name="l1350"><span class="ln">1350 </span></a>        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">== </span><span class="s4">'x'</span><span class="s3">:</span>
<a name="l1351"><span class="ln">1351 </span></a>            <span class="s1">submergedAmt </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">- (</span>
<a name="l1352"><span class="ln">1352 </span></a>                        <span class="s3">-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] + </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__xCollisionLine</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]]) * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1353"><span class="ln">1353 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume </span><span class="s3">= </span><span class="s1">capVolume</span><span class="s3">(</span><span class="s1">submergedAmt</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)</span>
<a name="l1354"><span class="ln">1354 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedArea </span><span class="s3">= </span><span class="s1">capArea</span><span class="s3">(</span><span class="s1">submergedAmt</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">)</span>
<a name="l1355"><span class="ln">1355 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedRadius </span><span class="s3">= </span><span class="s1">submergedAmt</span>
<a name="l1356"><span class="ln">1356 </span></a>        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume</span><span class="s3">) &gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume</span><span class="s3">:</span>
<a name="l1357"><span class="ln">1357 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume</span>
<a name="l1358"><span class="ln">1358 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cubeSubmersion</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:  </span><span class="s0"># if fully submerged</span>
<a name="l1359"><span class="ln">1359 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume</span>
<a name="l1360"><span class="ln">1360 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedRadius </span><span class="s3">&gt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">:  </span><span class="s0"># if half (or more) of sphere is submerged</span>
<a name="l1361"><span class="ln">1361 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedArea </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__halfArea</span>
<a name="l1362"><span class="ln">1362 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedRadius </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span>
<a name="l1363"><span class="ln">1363 </span></a>        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l1364"><span class="ln">1364 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidUpthrust</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">density </span><span class="s3">* -</span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'gField'</span><span class="s3">][</span>
<a name="l1365"><span class="ln">1365 </span></a>                <span class="s1">axis</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedVolume  </span><span class="s0"># Upthrust = fluid density * -gravitational field strength * submerged volume</span>
<a name="l1366"><span class="ln">1366 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__liquidDrag</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = (</span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">viscosity </span><span class="s3">* (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] ** </span><span class="s5">2</span><span class="s3">) * -</span><span class="s1">getSign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span>
<a name="l1367"><span class="ln">1367 </span></a>                                                                                                      <span class="s1">axis</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__submergedArea</span><span class="s3">)  </span><span class="s0"># Drag = 1/2 * drag coefficient (viscosity) * fluid density * velocity² * -moving direction</span>
<a name="l1368"><span class="ln">1368 </span></a>
<a name="l1369"><span class="ln">1369 </span></a>    <span class="s2">def </span><span class="s1">__planeCollisionSolid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">crIdx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1370"><span class="ln">1370 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1371"><span class="ln">1371 </span></a>        :param crIdx: index of the colliding collisionRect in the collisionRect list. 
<a name="l1372"><span class="ln">1372 </span></a>        :param cr: colliding collisionRect object 
<a name="l1373"><span class="ln">1373 </span></a> 
<a name="l1374"><span class="ln">1374 </span></a>        this method is used to resolve point&lt;&gt;collisionRect plane (surface) collisions. 
<a name="l1375"><span class="ln">1375 </span></a> 
<a name="l1376"><span class="ln">1376 </span></a>        process: 
<a name="l1377"><span class="ln">1377 </span></a>            1. get the colliding collisionRect object from the collisionRect list. 
<a name="l1378"><span class="ln">1378 </span></a>            2. check collisionState: 
<a name="l1379"><span class="ln">1379 </span></a>                if it's 'y': use y = mx + c. 
<a name="l1380"><span class="ln">1380 </span></a>                if it's 'x': use x = my + c. 
<a name="l1381"><span class="ln">1381 </span></a>                this is done so that gradient 'm' is always &lt;= 1 so that there's lots of decimal places available for more accurate floating point precision. 
<a name="l1382"><span class="ln">1382 </span></a>            3. teleport the point to the surface of the plane by getting the x/y coordinate of its line equation, displacing the teleportation by the point's radius. 
<a name="l1383"><span class="ln">1383 </span></a>                a) if the point hasn't collided with a collisionRect yet, set colliding to True and apply an impulse based on the momentum of the point relative to the collisionRect plane. 
<a name="l1384"><span class="ln">1384 </span></a>                    imagine dropping a ball onto a slope. it won't fully stop as it hits the slope; it'll be shot down the slope! that's why an impulse is applied at the point of collision here. 
<a name="l1385"><span class="ln">1385 </span></a>                b) also teleport the point to the collisionRect's surface about the x and y axes. if the point has already collided, only teleport the point. 
<a name="l1386"><span class="ln">1386 </span></a>                    radius is accounted for here otherwise half the point will get stuck inside the collisionRect. 
<a name="l1387"><span class="ln">1387 </span></a>                    for all radius displacements, 'multiplier' is used to get which direction to displace the point by, since displacement should be reversed for 'left'/'bottom'/'back' collisions. 
<a name="l1388"><span class="ln">1388 </span></a>            4. if the point is colliding with the 'front'/'back' of a collisionRect, no need for any fancy line equations. 
<a name="l1389"><span class="ln">1389 </span></a>                just teleport the point to the surface of the plane, factoring in radius. 
<a name="l1390"><span class="ln">1390 </span></a>        &quot;&quot;&quot;</span>
<a name="l1391"><span class="ln">1391 </span></a>        <span class="s1">cr </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]  </span><span class="s0"># alis for the colliding collisionRect object</span>
<a name="l1392"><span class="ln">1392 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'top'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'right'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span>
<a name="l1393"><span class="ln">1393 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'bottom'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span>
<a name="l1394"><span class="ln">1394 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'left'</span><span class="s3">):  </span><span class="s0"># colliding with top/right/bottom/left plane</span>
<a name="l1395"><span class="ln">1395 </span></a>            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">== </span><span class="s4">'y'</span><span class="s3">:</span>
<a name="l1396"><span class="ln">1396 </span></a>                <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:</span>
<a name="l1397"><span class="ln">1397 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l1398"><span class="ln">1398 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] + (</span>
<a name="l1399"><span class="ln">1399 </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">cos</span><span class="s3">(</span>
<a name="l1400"><span class="ln">1400 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))  </span><span class="s0"># use y = mx + c where m &lt;= 1 and y = cords[1]</span>
<a name="l1401"><span class="ln">1401 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
<a name="l1402"><span class="ln">1402 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
<a name="l1403"><span class="ln">1403 </span></a>                    <span class="s1">resultP </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])) + (</span>
<a name="l1404"><span class="ln">1404 </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1405"><span class="ln">1405 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">resultP </span><span class="s3">* </span><span class="s1">physicsTime </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">e</span>
<a name="l1406"><span class="ln">1406 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">resultP </span><span class="s3">* </span><span class="s1">physicsTime </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">e</span>
<a name="l1407"><span class="ln">1407 </span></a>                <span class="s2">else</span><span class="s3">:</span>
<a name="l1408"><span class="ln">1408 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1409"><span class="ln">1409 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__yCollisionLine</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] + (</span>
<a name="l1410"><span class="ln">1410 </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1411"><span class="ln">1411 </span></a>            <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__collisionState </span><span class="s3">== </span><span class="s4">'x'</span><span class="s3">:</span>
<a name="l1412"><span class="ln">1412 </span></a>                <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:</span>
<a name="l1413"><span class="ln">1413 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l1414"><span class="ln">1414 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__xCollisionLine</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] - (</span>
<a name="l1415"><span class="ln">1415 </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">sin</span><span class="s3">(</span>
<a name="l1416"><span class="ln">1416 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))  </span><span class="s0"># use x = my + c where m &lt;= 1 and x = cords[0]</span>
<a name="l1417"><span class="ln">1417 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
<a name="l1418"><span class="ln">1418 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
<a name="l1419"><span class="ln">1419 </span></a>                    <span class="s1">resultP </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])) + (</span>
<a name="l1420"><span class="ln">1420 </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">mass </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">velocity</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1421"><span class="ln">1421 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">resultP </span><span class="s3">* </span><span class="s1">physicsTime </span><span class="s3">* </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">e</span>
<a name="l1422"><span class="ln">1422 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">resultP </span><span class="s3">* </span><span class="s1">physicsTime </span><span class="s3">* </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">e</span>
<a name="l1423"><span class="ln">1423 </span></a>                <span class="s2">else</span><span class="s3">:</span>
<a name="l1424"><span class="ln">1424 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__impulse </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1425"><span class="ln">1425 </span></a>                    <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__xCollisionLine</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] - (</span>
<a name="l1426"><span class="ln">1426 </span></a>                                <span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">/ </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__bAngle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1427"><span class="ln">1427 </span></a>        <span class="s2">elif </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'front'</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] == </span><span class="s4">'back'</span><span class="s3">):</span>
<a name="l1428"><span class="ln">1428 </span></a>            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]:</span>
<a name="l1429"><span class="ln">1429 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">colliding</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">] = </span><span class="s2">True</span>
<a name="l1430"><span class="ln">1430 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">])</span>
<a name="l1431"><span class="ln">1431 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>
<a name="l1432"><span class="ln">1432 </span></a>            <span class="s2">else</span><span class="s3">:</span>
<a name="l1433"><span class="ln">1433 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">collision</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">]] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__multiplier</span><span class="s3">[</span><span class="s1">crIdx</span><span class="s3">])</span>
<a name="l1434"><span class="ln">1434 </span></a>
<a name="l1435"><span class="ln">1435 </span></a>
<a name="l1436"><span class="ln">1436 </span></a><span class="s0"># class for cylinders (joints) connecting spheres</span>
<a name="l1437"><span class="ln">1437 </span></a><span class="s2">class </span><span class="s1">Joint</span><span class="s3">:</span>
<a name="l1438"><span class="ln">1438 </span></a>    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">show</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">origLength</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">stiffness</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">pOne</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">pTwo</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">bounciness</span><span class="s3">: </span><span class="s1">float</span><span class="s3">,</span>
<a name="l1439"><span class="ln">1439 </span></a>                 <span class="s1">maxStrain</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">gameObj</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1440"><span class="ln">1440 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">pOne </span><span class="s3">= </span><span class="s1">pOne  </span><span class="s0"># index of first connected point</span>
<a name="l1441"><span class="ln">1441 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo </span><span class="s3">= </span><span class="s1">pTwo  </span><span class="s0"># index of second connected point</span>
<a name="l1442"><span class="ln">1442 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__length </span><span class="s3">= </span><span class="s1">distance</span><span class="s3">(</span><span class="s1">gameObj</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">,</span>
<a name="l1443"><span class="ln">1443 </span></a>                                 <span class="s1">gameObj</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">)  </span><span class="s0"># current size of joint</span>
<a name="l1444"><span class="ln">1444 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__oldLength </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length  </span><span class="s0"># size of joint from previous frame</span>
<a name="l1445"><span class="ln">1445 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">= </span><span class="s1">jointRadius</span>
<a name="l1446"><span class="ln">1446 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">stiffness </span><span class="s3">= </span><span class="s1">stiffness</span>
<a name="l1447"><span class="ln">1447 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">dampingConst </span><span class="s3">= </span><span class="s1">bounciness</span>
<a name="l1448"><span class="ln">1448 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1449"><span class="ln">1449 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">angle </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1450"><span class="ln">1450 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">show </span><span class="s3">= </span><span class="s1">show</span>
<a name="l1451"><span class="ln">1451 </span></a>        <span class="s2">if </span><span class="s1">origLength </span><span class="s3">== </span><span class="s4">''</span><span class="s3">:</span>
<a name="l1452"><span class="ln">1452 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">origLength </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">)</span>
<a name="l1453"><span class="ln">1453 </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l1454"><span class="ln">1454 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">origLength </span><span class="s3">= </span><span class="s1">origLength</span>
<a name="l1455"><span class="ln">1455 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">maxStrain </span><span class="s3">= </span><span class="s1">maxStrain  </span><span class="s0"># maximum length of joint before breaking</span>
<a name="l1456"><span class="ln">1456 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">diff </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]  </span><span class="s0"># caching variable, avoiding repeat calcs to increase performance</span>
<a name="l1457"><span class="ln">1457 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1458"><span class="ln">1458 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__damping </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1459"><span class="ln">1459 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__dampingCoef </span><span class="s3">= </span><span class="s5">1  </span><span class="s0"># coefficient of damping independent of globalVars['damping']</span>
<a name="l1460"><span class="ln">1460 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">show</span><span class="s3">:</span>
<a name="l1461"><span class="ln">1461 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cylinder </span><span class="s3">= </span><span class="s1">vizshape</span><span class="s3">.</span><span class="s1">addCylinder</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">slices</span><span class="s3">=</span><span class="s1">jointResolution</span><span class="s3">)  </span><span class="s0"># make the joint visible if shown</span>
<a name="l1462"><span class="ln">1462 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__volume </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">** </span><span class="s5">2</span><span class="s3">) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span>
<a name="l1463"><span class="ln">1463 </span></a>
<a name="l1464"><span class="ln">1464 </span></a>    <span class="s0"># update the position and appearance of the joint</span>
<a name="l1465"><span class="ln">1465 </span></a>    <span class="s2">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1466"><span class="ln">1466 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1467"><span class="ln">1467 </span></a>        this method is used to update the position and appearance of the joint in the Vizard game scene. 
<a name="l1468"><span class="ln">1468 </span></a> 
<a name="l1469"><span class="ln">1469 </span></a>        process: 
<a name="l1470"><span class="ln">1470 </span></a>            1. get the difference in position between both points about each axis. 
<a name="l1471"><span class="ln">1471 </span></a>            2. save the length from the current frame for use in calculating damping force in the next frame. 
<a name="l1472"><span class="ln">1472 </span></a>            3. set the current length to the distance between both points, as long as this distance isn't 0. let game.diff be game.diff[pOne][pTwo]: 
<a name="l1473"><span class="ln">1473 </span></a>                since the 'getDist' method from the game instance makes it so that pIdx0 must always be larger than pIdx1. 
<a name="l1474"><span class="ln">1474 </span></a>                this must be used to compensate for &quot;also don't get distance between 2 points if you already have it!&quot; as seen in getDist() from the Main class, where 'po &gt; p'. 
<a name="l1475"><span class="ln">1475 </span></a>            4. update the visual radius of the joint based on its new length, since volume should always remain constant (since no mass of the joint is ever lost). 
<a name="l1476"><span class="ln">1476 </span></a>                increasing length decreases radius since radius = sqrt(volume / (π * height)). 
<a name="l1477"><span class="ln">1477 </span></a>        &quot;&quot;&quot;</span>
<a name="l1478"><span class="ln">1478 </span></a>
<a name="l1479"><span class="ln">1479 </span></a>        <span class="s0"># if self.__length &gt;= (self.origLength * self.maxStrain):</span>
<a name="l1480"><span class="ln">1480 </span></a>        <span class="s0">#     self.snap()  # MASSIVE WIP</span>
<a name="l1481"><span class="ln">1481 </span></a>
<a name="l1482"><span class="ln">1482 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">diff </span><span class="s3">= </span><span class="s1">displacement</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l1483"><span class="ln">1483 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__oldLength </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span>
<a name="l1484"><span class="ln">1484 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne </span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">):</span>
<a name="l1485"><span class="ln">1485 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__length </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">]</span>
<a name="l1486"><span class="ln">1486 </span></a>        <span class="s2">elif </span><span class="s1">game</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:</span>
<a name="l1487"><span class="ln">1487 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__length </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">][</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">]</span>
<a name="l1488"><span class="ln">1488 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">radius </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__volume </span><span class="s3">/ (</span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">))  </span><span class="s0"># r = sqrt(v / πh)</span>
<a name="l1489"><span class="ln">1489 </span></a>        <span class="s0"># no need to reassign volume here since it always stays constant</span>
<a name="l1490"><span class="ln">1490 </span></a>
<a name="l1491"><span class="ln">1491 </span></a>    <span class="s0"># used to draw the joint in the Vizard game scene. only runs if the joint is shown.</span>
<a name="l1492"><span class="ln">1492 </span></a>    <span class="s2">def </span><span class="s1">draw</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1493"><span class="ln">1493 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">show</span><span class="s3">:</span>
<a name="l1494"><span class="ln">1494 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cylinder</span><span class="s3">.</span><span class="s1">setScale</span><span class="s3">(</span>
<a name="l1495"><span class="ln">1495 </span></a>                <span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">radius</span><span class="s3">])  </span><span class="s0"># change visual size of the joint in the Vizard game scene</span>
<a name="l1496"><span class="ln">1496 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">midpoint</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">], </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">])</span>
<a name="l1497"><span class="ln">1497 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cylinder</span><span class="s3">.</span><span class="s1">setPosition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)  </span><span class="s0"># set the position of the joint in the Vizard game scene</span>
<a name="l1498"><span class="ln">1498 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">cylinder</span><span class="s3">.</span><span class="s1">setEuler</span><span class="s3">(</span><span class="s1">getEulerAngle</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">))</span>
<a name="l1499"><span class="ln">1499 </span></a>
<a name="l1500"><span class="ln">1500 </span></a>    <span class="s0"># constrain points connected to this joint</span>
<a name="l1501"><span class="ln">1501 </span></a>    <span class="s2">def </span><span class="s1">constrain</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1502"><span class="ln">1502 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1503"><span class="ln">1503 </span></a>        this method is used to calculate the constraint force (tension) in each joint on connected points. 
<a name="l1504"><span class="ln">1504 </span></a> 
<a name="l1505"><span class="ln">1505 </span></a>        process: 
<a name="l1506"><span class="ln">1506 </span></a>            1. if there's a change in length of the joint (since there's no need to do calculations if their result isn't going to change), and its length isn't 0 (prevents dividing by 0): 
<a name="l1507"><span class="ln">1507 </span></a>                a) calculate 'constrainForce' using F = spring constant * extension for each axis: https://drive.google.com/file/d/14lx-43spyHGvXsNz7zKPZd1ALsERDYLw/view?usp=drive_link 
<a name="l1508"><span class="ln">1508 </span></a>                    this is done by multiplying the ratio of current length to length about each axis with the extension of the joint. 
<a name="l1509"><span class="ln">1509 </span></a>                    this ratio is calculated in 'self.diff[u] / self.length', where 'u' is the current axis' index. 
<a name="l1510"><span class="ln">1510 </span></a>                    extension is calculated for constraint force in 'origLength - length'. 
<a name="l1511"><span class="ln">1511 </span></a>                b) calculate the damping force about each axis: https://drive.google.com/file/d/1aQkf92qq8nMDpdk53Bs-iAaJB7V96GxW/view?usp=drive_link 
<a name="l1512"><span class="ln">1512 </span></a>                    damping force = damping constant * change in joint length from last frame (lRel) * ratio of current length to length * -resultant direction of motion 
<a name="l1513"><span class="ln">1513 </span></a>            2. apply the calculated constraint force minus the damping to each point in opposite directions (opposite due to Newton's 3rd law). 
<a name="l1514"><span class="ln">1514 </span></a>        &quot;&quot;&quot;</span>
<a name="l1515"><span class="ln">1515 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">origLength</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">):</span>
<a name="l1516"><span class="ln">1516 </span></a>            <span class="s2">for </span><span class="s1">u </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l1517"><span class="ln">1517 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce</span><span class="s3">[</span><span class="s1">u</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stiffness </span><span class="s3">* (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">u</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">) * (</span>
<a name="l1518"><span class="ln">1518 </span></a>                            <span class="s1">self</span><span class="s3">.</span><span class="s1">origLength </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">)</span>
<a name="l1519"><span class="ln">1519 </span></a>                <span class="s1">self</span><span class="s3">.</span><span class="s1">__damping</span><span class="s3">[</span><span class="s1">u</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dampingCoef </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dampingConst </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span>
<a name="l1520"><span class="ln">1520 </span></a>                    <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">[</span><span class="s1">u</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">) * (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__oldLength </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">)) * </span><span class="s1">physicsTime </span><span class="s3">* </span><span class="s1">getSign</span><span class="s3">(</span>
<a name="l1521"><span class="ln">1521 </span></a>                    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">u</span><span class="s3">] - </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">velocity</span><span class="s3">[</span><span class="s1">u</span><span class="s3">])</span>
<a name="l1522"><span class="ln">1522 </span></a>        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l1523"><span class="ln">1523 </span></a>            <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">constrainForce</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__damping</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
<a name="l1524"><span class="ln">1524 </span></a>            <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">constrainForce</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] -= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">constrainForce</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__damping</span><span class="s3">[</span>
<a name="l1525"><span class="ln">1525 </span></a>                <span class="s1">i</span><span class="s3">]  </span><span class="s0"># negative due to Newton's 3rd law</span>
<a name="l1526"><span class="ln">1526 </span></a>
<a name="l1527"><span class="ln">1527 </span></a>    <span class="s0"># break the joint after extending a specified distance (MASSIVE WIP)</span>
<a name="l1528"><span class="ln">1528 </span></a>    <span class="s2">def </span><span class="s1">__snap</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1529"><span class="ln">1529 </span></a>        <span class="s0"># radius cannot be less than 0.05 due to floating point error</span>
<a name="l1530"><span class="ln">1530 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s5">2</span><span class="s3">) &lt; </span><span class="s1">minRadius</span><span class="s3">:</span>
<a name="l1531"><span class="ln">1531 </span></a>            <span class="s1">pointRad </span><span class="s3">= </span><span class="s1">minRadius</span>
<a name="l1532"><span class="ln">1532 </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l1533"><span class="ln">1533 </span></a>            <span class="s1">pointRad </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l1534"><span class="ln">1534 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">Point</span><span class="s3">(</span><span class="s1">pointRad</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">density</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">))</span>
<a name="l1535"><span class="ln">1535 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">setRadiusDensity</span><span class="s3">(</span><span class="s1">pointRad</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">density</span><span class="s3">)</span>
<a name="l1536"><span class="ln">1536 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">disabledPointCollisions </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1537"><span class="ln">1537 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l1538"><span class="ln">1538 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l1539"><span class="ln">1539 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1540"><span class="ln">1540 </span></a>            <span class="s1">Joint</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">origLength </span><span class="s3">* </span><span class="s5">2</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stiffness </span><span class="s3">/ </span><span class="s5">8</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dampingConst</span><span class="s3">,</span>
<a name="l1541"><span class="ln">1541 </span></a>                  <span class="s1">self</span><span class="s3">.</span><span class="s1">maxStrain </span><span class="s3">* </span><span class="s5">2</span><span class="s3">,</span>
<a name="l1542"><span class="ln">1542 </span></a>                  <span class="s1">game</span><span class="s3">))  </span><span class="s0"># maxStrain is increased since whenever materials break, since they pass their elastic limit in reality</span>
<a name="l1543"><span class="ln">1543 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)  </span><span class="s0"># unique cloth key</span>
<a name="l1544"><span class="ln">1544 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pOne </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)</span>
<a name="l1545"><span class="ln">1545 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">updateLists</span><span class="s3">()  </span><span class="s0"># more points and joints means that relevant info needs to be updated for each point</span>
<a name="l1546"><span class="ln">1546 </span></a>
<a name="l1547"><span class="ln">1547 </span></a>        <span class="s2">if </span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s5">2</span><span class="s3">) &lt; </span><span class="s1">minRadius</span><span class="s3">:</span>
<a name="l1548"><span class="ln">1548 </span></a>            <span class="s1">pointRad </span><span class="s3">= </span><span class="s1">minRadius</span>
<a name="l1549"><span class="ln">1549 </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l1550"><span class="ln">1550 </span></a>            <span class="s1">pointRad </span><span class="s3">= </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">radius </span><span class="s3">/ </span><span class="s5">2</span>
<a name="l1551"><span class="ln">1551 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">stiffness </span><span class="s3">/= </span><span class="s5">8</span>
<a name="l1552"><span class="ln">1552 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">Point</span><span class="s3">(</span><span class="s1">pointRad</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">density</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">))</span>
<a name="l1553"><span class="ln">1553 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">setRadiusDensity</span><span class="s3">(</span><span class="s1">pointRad</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">density</span><span class="s3">)</span>
<a name="l1554"><span class="ln">1554 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">pOne </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span>
<a name="l1555"><span class="ln">1555 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l1556"><span class="ln">1556 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l1557"><span class="ln">1557 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">disabledPointCollisions </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1558"><span class="ln">1558 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">origLength </span><span class="s3">*= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">maxStrain</span>
<a name="l1559"><span class="ln">1559 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">origLength </span><span class="s3">*= </span><span class="s5">2</span>
<a name="l1560"><span class="ln">1560 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">diff </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1561"><span class="ln">1561 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__length </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">origLength</span><span class="s3">)</span>
<a name="l1562"><span class="ln">1562 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__oldLength </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__length</span><span class="s3">)</span>
<a name="l1563"><span class="ln">1563 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">maxStrain </span><span class="s3">*= </span><span class="s5">2</span>
<a name="l1564"><span class="ln">1564 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)  </span><span class="s0"># unique cloth key</span>
<a name="l1565"><span class="ln">1565 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pTwo </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)</span>
<a name="l1566"><span class="ln">1566 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">updateLists</span><span class="s3">()  </span><span class="s0"># more points and joints means that relevant info needs to be updated for each point</span>
<a name="l1567"><span class="ln">1567 </span></a>
<a name="l1568"><span class="ln">1568 </span></a>
<a name="l1569"><span class="ln">1569 </span></a><span class="s2">class </span><span class="s1">CollisionRect</span><span class="s3">:</span>
<a name="l1570"><span class="ln">1570 </span></a>    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">size</span><span class="s3">: </span><span class="s1">list</span><span class="s3">, </span><span class="s1">cords</span><span class="s3">: </span><span class="s1">list</span><span class="s3">, </span><span class="s1">angle</span><span class="s3">: </span><span class="s1">list</span><span class="s3">, </span><span class="s1">density</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">viscosity</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">dragConst</span><span class="s3">: </span><span class="s1">float</span><span class="s3">,</span>
<a name="l1571"><span class="ln">1571 </span></a>                 <span class="s1">transparency</span><span class="s3">: </span><span class="s1">float</span><span class="s3">, </span><span class="s1">rectType</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">hide</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1572"><span class="ln">1572 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">rectType  </span><span class="s0"># solid or liquid</span>
<a name="l1573"><span class="ln">1573 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">angle </span><span class="s3">= </span><span class="s1">angle</span>
<a name="l1574"><span class="ln">1574 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexAngle </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1575"><span class="ln">1575 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">size </span><span class="s3">= </span><span class="s1">size</span>
<a name="l1576"><span class="ln">1576 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">show </span><span class="s3">= </span><span class="s2">False</span>
<a name="l1577"><span class="ln">1577 </span></a>        <span class="s2">if not </span><span class="s1">hide</span><span class="s3">:</span>
<a name="l1578"><span class="ln">1578 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">show </span><span class="s3">= </span><span class="s2">True</span>
<a name="l1579"><span class="ln">1579 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__rect </span><span class="s3">= </span><span class="s1">vizshape</span><span class="s3">.</span><span class="s1">addBox</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>
<a name="l1580"><span class="ln">1580 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__rect</span><span class="s3">.</span><span class="s1">setScale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
<a name="l1581"><span class="ln">1581 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">cords </span><span class="s3">= </span><span class="s1">cords</span>
<a name="l1582"><span class="ln">1582 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">density </span><span class="s3">= </span><span class="s1">density</span>
<a name="l1583"><span class="ln">1583 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">dragConst </span><span class="s3">= </span><span class="s1">dragConst</span>
<a name="l1584"><span class="ln">1584 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">viscosity </span><span class="s3">= </span><span class="s1">viscosity</span>
<a name="l1585"><span class="ln">1585 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">transparency </span><span class="s3">= </span><span class="s1">transparency</span>
<a name="l1586"><span class="ln">1586 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">vertex </span><span class="s3">= []  </span><span class="s0"># vertices ordered in: [['right', 'top', 'front'], ['left', 'top', 'front'], ['left', 'bottom', 'front'], ['left', 'bottom', 'back'], ['left', 'top', 'back'], ['right', 'top', 'back'], ['right', 'bottom', 'back'], ['right', 'bottom', 'front']]</span>
<a name="l1587"><span class="ln">1587 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane </span><span class="s3">= {</span>
<a name="l1588"><span class="ln">1588 </span></a>            <span class="s4">'front'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
<a name="l1589"><span class="ln">1589 </span></a>            <span class="s4">'back'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
<a name="l1590"><span class="ln">1590 </span></a>            <span class="s4">'left'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
<a name="l1591"><span class="ln">1591 </span></a>            <span class="s4">'right'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
<a name="l1592"><span class="ln">1592 </span></a>            <span class="s4">'top'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
<a name="l1593"><span class="ln">1593 </span></a>            <span class="s4">'bottom'</span><span class="s3">: </span><span class="s5">0</span>
<a name="l1594"><span class="ln">1594 </span></a>        <span class="s3">}</span>
<a name="l1595"><span class="ln">1595 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">grad </span><span class="s3">= </span><span class="s1">dict</span>
<a name="l1596"><span class="ln">1596 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">sf </span><span class="s3">= </span><span class="s5">1</span>
<a name="l1597"><span class="ln">1597 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">update</span><span class="s3">()</span>
<a name="l1598"><span class="ln">1598 </span></a>
<a name="l1599"><span class="ln">1599 </span></a>    <span class="s2">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
<a name="l1600"><span class="ln">1600 </span></a>        <span class="s6">&quot;&quot;&quot; 
<a name="l1601"><span class="ln">1601 </span></a>        this method is used to calculate the positions of vertices and determine other properties of a collisionRect. 
<a name="l1602"><span class="ln">1602 </span></a> 
<a name="l1603"><span class="ln">1603 </span></a>        process: 
<a name="l1604"><span class="ln">1604 </span></a>            1. set the size, position, angle, and transparency of the collisionRect in the Vizard game scene. 
<a name="l1605"><span class="ln">1605 </span></a>                only do this if the collisionRect is drawn in the Vizard game scene! 
<a name="l1606"><span class="ln">1606 </span></a>            2. get 'sizeMultiplier' and 'multiplier' to get the relative direction to displace each vertex when updating their new positions in the next step. 
<a name="l1607"><span class="ln">1607 </span></a>            3. displace each vertex from their initial positions given the angle of the collisionRect. 
<a name="l1608"><span class="ln">1608 </span></a>                https://drive.google.com/file/d/1XcQUu377kNwbsxM5kiE_QrgbgAowziEC/view?usp=drive_link 
<a name="l1609"><span class="ln">1609 </span></a>            4. set the x, y, or z cords for each plane depending on their facing direction. 
<a name="l1610"><span class="ln">1610 </span></a>            5. calculate gradient for y = mx + c and x = my + c, and put the results into the 'grad' dictionary. 
<a name="l1611"><span class="ln">1611 </span></a>                despite m(x) = -1/my, using a negative reciprocal isn't accurate here due to floating point precision! 
<a name="l1612"><span class="ln">1612 </span></a>                also handle an exception in which gradient could be infinity. 
<a name="l1613"><span class="ln">1613 </span></a>        &quot;&quot;&quot;</span>
<a name="l1614"><span class="ln">1614 </span></a>
<a name="l1615"><span class="ln">1615 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">show</span><span class="s3">:</span>
<a name="l1616"><span class="ln">1616 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__rect</span><span class="s3">.</span><span class="s1">setScale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
<a name="l1617"><span class="ln">1617 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__rect</span><span class="s3">.</span><span class="s1">setPosition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">)</span>
<a name="l1618"><span class="ln">1618 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__rect</span><span class="s3">.</span><span class="s1">setEuler</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]))</span>
<a name="l1619"><span class="ln">1619 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">__rect</span><span class="s3">.</span><span class="s1">alpha</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">transparency</span><span class="s3">)</span>
<a name="l1620"><span class="ln">1620 </span></a>        <span class="s1">sizeMultiplier </span><span class="s3">= [</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">]</span>
<a name="l1621"><span class="ln">1621 </span></a>        <span class="s1">multiplier </span><span class="s3">= </span><span class="s5">1</span>
<a name="l1622"><span class="ln">1622 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexAngle </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
<a name="l1623"><span class="ln">1623 </span></a>        <span class="s0"># determine which axes should be reversed when updating the xyz cords of vertices</span>
<a name="l1624"><span class="ln">1624 </span></a>        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">8</span><span class="s3">):</span>
<a name="l1625"><span class="ln">1625 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">5</span><span class="s3">):</span>
<a name="l1626"><span class="ln">1626 </span></a>                <span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = -</span><span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
<a name="l1627"><span class="ln">1627 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">4</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">6</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">2</span><span class="s3">):</span>
<a name="l1628"><span class="ln">1628 </span></a>                <span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = -</span><span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1629"><span class="ln">1629 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">3</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">7</span><span class="s3">):</span>
<a name="l1630"><span class="ln">1630 </span></a>                <span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = -</span><span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>
<a name="l1631"><span class="ln">1631 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">4</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">6</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">7</span><span class="s3">):</span>
<a name="l1632"><span class="ln">1632 </span></a>                <span class="s1">multiplier </span><span class="s3">= -</span><span class="s5">1</span>
<a name="l1633"><span class="ln">1633 </span></a>            <span class="s2">elif </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">5</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">2</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">v </span><span class="s3">== </span><span class="s5">3</span><span class="s3">):</span>
<a name="l1634"><span class="ln">1634 </span></a>                <span class="s1">multiplier </span><span class="s3">= </span><span class="s5">1</span>
<a name="l1635"><span class="ln">1635 </span></a>
<a name="l1636"><span class="ln">1636 </span></a>            <span class="s0"># get the position of the vertices of the collisionRect by using trig to displace the vertices from their original positions at 0 degrees to 'bAngle[2]' degrees</span>
<a name="l1637"><span class="ln">1637 </span></a>            <span class="s1">tempVertex </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<a name="l1638"><span class="ln">1638 </span></a>            <span class="s1">xySize </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) ** </span><span class="s5">2 </span><span class="s3">+ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) ** </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1639"><span class="ln">1639 </span></a>            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">):</span>
<a name="l1640"><span class="ln">1640 </span></a>                <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># x</span>
<a name="l1641"><span class="ln">1641 </span></a>                    <span class="s1">tempVertex</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + (</span>
<a name="l1642"><span class="ln">1642 </span></a>                                <span class="s1">xySize </span><span class="s3">* </span><span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexAngle </span><span class="s3">+ (</span><span class="s1">multiplier </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])))</span>
<a name="l1643"><span class="ln">1643 </span></a>                <span class="s2">elif </span><span class="s1">i </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:  </span><span class="s0"># y</span>
<a name="l1644"><span class="ln">1644 </span></a>                    <span class="s1">tempVertex</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + (</span>
<a name="l1645"><span class="ln">1645 </span></a>                                <span class="s1">xySize </span><span class="s3">* </span><span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__vertexAngle </span><span class="s3">+ (</span><span class="s1">multiplier </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])))</span>
<a name="l1646"><span class="ln">1646 </span></a>                <span class="s2">elif </span><span class="s1">i </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:  </span><span class="s0"># z</span>
<a name="l1647"><span class="ln">1647 </span></a>                    <span class="s1">tempVertex</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">sizeMultiplier</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
<a name="l1648"><span class="ln">1648 </span></a>
<a name="l1649"><span class="ln">1649 </span></a>            <span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tempVertex</span><span class="s3">)</span>
<a name="l1650"><span class="ln">1650 </span></a>
<a name="l1651"><span class="ln">1651 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'right'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1652"><span class="ln">1652 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'left'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1653"><span class="ln">1653 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'top'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1654"><span class="ln">1654 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'bottom'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1655"><span class="ln">1655 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'front'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] + (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1656"><span class="ln">1656 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">plane</span><span class="s3">[</span><span class="s4">'back'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] - (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">)</span>
<a name="l1657"><span class="ln">1657 </span></a>
<a name="l1658"><span class="ln">1658 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]:</span>
<a name="l1659"><span class="ln">1659 </span></a>            <span class="s1">mx </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]) / (</span>
<a name="l1660"><span class="ln">1660 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">])  </span><span class="s0"># calculate gradient using y2-y1 / x2-x1</span>
<a name="l1661"><span class="ln">1661 </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l1662"><span class="ln">1662 </span></a>            <span class="s1">mx </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s4">'inf'</span><span class="s3">)</span>
<a name="l1663"><span class="ln">1663 </span></a>        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]:</span>
<a name="l1664"><span class="ln">1664 </span></a>            <span class="s1">my </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]) / (</span>
<a name="l1665"><span class="ln">1665 </span></a>                        <span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vertex</span><span class="s3">[</span><span class="s5">7</span><span class="s3">][</span><span class="s5">0</span><span class="s3">])  </span><span class="s0"># calculate gradient using x2-x1 / y2-y1</span>
<a name="l1666"><span class="ln">1666 </span></a>        <span class="s2">else</span><span class="s3">:</span>
<a name="l1667"><span class="ln">1667 </span></a>            <span class="s1">my </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s4">'inf'</span><span class="s3">)</span>
<a name="l1668"><span class="ln">1668 </span></a>        <span class="s1">self</span><span class="s3">.</span><span class="s1">grad </span><span class="s3">= {</span>
<a name="l1669"><span class="ln">1669 </span></a>            <span class="s4">'x'</span><span class="s3">: </span><span class="s1">mx</span><span class="s3">,</span>
<a name="l1670"><span class="ln">1670 </span></a>            <span class="s4">'y'</span><span class="s3">: </span><span class="s1">my</span>
<a name="l1671"><span class="ln">1671 </span></a>        <span class="s3">}</span>
<a name="l1672"><span class="ln">1672 </span></a>
<a name="l1673"><span class="ln">1673 </span></a>
<a name="l1674"><span class="ln">1674 </span></a><span class="s1">game </span><span class="s3">= </span><span class="s1">Main</span><span class="s3">()</span>
<a name="l1675"><span class="ln">1675 </span></a>
<a name="l1676"><span class="ln">1676 </span></a><span class="s0"># makes sample points, joints, and collisionRects</span>
<a name="l1677"><span class="ln">1677 </span></a><span class="s2">if not </span><span class="s1">imports</span><span class="s3">:</span>
<a name="l1678"><span class="ln">1678 </span></a>    <span class="s2">for </span><span class="s1">ve </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">8</span><span class="s3">):</span>
<a name="l1679"><span class="ln">1679 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">Point</span><span class="s3">(</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))  </span><span class="s0"># central point</span>
<a name="l1680"><span class="ln">1680 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">ve</span><span class="s3">].</span><span class="s1">cloth </span><span class="s3">= </span><span class="s4">'cube'</span>
<a name="l1681"><span class="ln">1681 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># top-front-right</span>
<a name="l1682"><span class="ln">1682 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1683"><span class="ln">1683 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># top-back-right</span>
<a name="l1684"><span class="ln">1684 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1685"><span class="ln">1685 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">2</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># top-back-left</span>
<a name="l1686"><span class="ln">1686 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">2</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1687"><span class="ln">1687 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">3</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]  </span><span class="s0"># top-front-left</span>
<a name="l1688"><span class="ln">1688 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">3</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1689"><span class="ln">1689 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">4</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1690"><span class="ln">1690 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">4</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1691"><span class="ln">1691 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">5</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1692"><span class="ln">1692 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">5</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1693"><span class="ln">1693 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">6</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1694"><span class="ln">1694 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">6</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]</span>
<a name="l1695"><span class="ln">1695 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">7</span><span class="s3">].</span><span class="s1">cords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1696"><span class="ln">1696 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s5">7</span><span class="s3">].</span><span class="s1">oldCords </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<a name="l1697"><span class="ln">1697 </span></a>
<a name="l1698"><span class="ln">1698 </span></a>    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l1699"><span class="ln">1699 </span></a>        <span class="s2">for </span><span class="s1">jo </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l1700"><span class="ln">1700 </span></a>            <span class="s2">if </span><span class="s3">(</span><span class="s1">j </span><span class="s3">!= </span><span class="s1">jo</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
<a name="l1701"><span class="ln">1701 </span></a>                    <span class="s1">jo </span><span class="s3">&gt; </span><span class="s1">j</span><span class="s3">):  </span><span class="s0"># performance optimisation: only go through unique combinations of j and jo (e.g. [1, 5] and [5, 0] are unique, but [1, 5] and [5, 1] are not)</span>
<a name="l1702"><span class="ln">1702 </span></a>                <span class="s1">game</span><span class="s3">.</span><span class="s1">joints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1703"><span class="ln">1703 </span></a>                    <span class="s1">Joint</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'springConst'</span><span class="s3">], </span><span class="s1">j</span><span class="s3">, </span><span class="s1">jo</span><span class="s3">, </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'damping'</span><span class="s3">], </span><span class="s1">globalVars</span><span class="s3">[</span><span class="s4">'strain'</span><span class="s3">],</span>
<a name="l1704"><span class="ln">1704 </span></a>                          <span class="s1">game</span><span class="s3">))</span>
<a name="l1705"><span class="ln">1705 </span></a>
<a name="l1706"><span class="ln">1706 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">Point</span><span class="s3">(</span><span class="s5">0.6</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))</span>
<a name="l1707"><span class="ln">1707 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">Point</span><span class="s3">(</span><span class="s5">0.4</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))</span>
<a name="l1708"><span class="ln">1708 </span></a>
<a name="l1709"><span class="ln">1709 </span></a>    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">)):</span>
<a name="l1710"><span class="ln">1710 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s5">50</span>
<a name="l1711"><span class="ln">1711 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s5">50</span>
<a name="l1712"><span class="ln">1712 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s5">20</span>
<a name="l1713"><span class="ln">1713 </span></a>        <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[</span><span class="s1">p</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s5">20</span>
<a name="l1714"><span class="ln">1714 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s5">10</span>
<a name="l1715"><span class="ln">1715 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s5">10</span>
<a name="l1716"><span class="ln">1716 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s5">10</span>
<a name="l1717"><span class="ln">1717 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] += </span><span class="s5">10</span>
<a name="l1718"><span class="ln">1718 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s5">10</span>
<a name="l1719"><span class="ln">1719 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s5">10</span>
<a name="l1720"><span class="ln">1720 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">].</span><span class="s1">cords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s5">20</span>
<a name="l1721"><span class="ln">1721 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">points</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">].</span><span class="s1">oldCords</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] -= </span><span class="s5">20</span>
<a name="l1722"><span class="ln">1722 </span></a>
<a name="l1723"><span class="ln">1723 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1724"><span class="ln">1724 </span></a>        <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s5">100</span><span class="s3">, </span><span class="s5">50</span><span class="s3">, </span><span class="s5">50</span><span class="s3">], [-</span><span class="s5">60</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span>
<a name="l1725"><span class="ln">1725 </span></a>                      <span class="s5">0.8</span><span class="s3">, </span><span class="s4">'s'</span><span class="s3">))  </span><span class="s0"># CANNOT be negative angle or above 90 (make near-zero for an angle of 0)</span>
<a name="l1726"><span class="ln">1726 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1727"><span class="ln">1727 </span></a>        <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s5">100</span><span class="s3">, </span><span class="s5">50</span><span class="s3">, </span><span class="s5">50</span><span class="s3">], [</span><span class="s5">60</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">30</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.8</span><span class="s3">,</span>
<a name="l1728"><span class="ln">1728 </span></a>                      <span class="s4">'s'</span><span class="s3">))</span>
<a name="l1729"><span class="ln">1729 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1730"><span class="ln">1730 </span></a>        <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s5">50</span><span class="s3">, </span><span class="s5">50</span><span class="s3">, </span><span class="s5">50</span><span class="s3">], [</span><span class="s5">170</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">2000</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s4">'l'</span><span class="s3">))</span>
<a name="l1731"><span class="ln">1731 </span></a>
<a name="l1732"><span class="ln">1732 </span></a><span class="s0"># make the borders (which are hidden collisionRects). size can be changed in 'config.py'.</span>
<a name="l1733"><span class="ln">1733 </span></a><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1734"><span class="ln">1734 </span></a>    <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s5">1</span><span class="s3">, </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]], [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">borderHeight</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span>
<a name="l1735"><span class="ln">1735 </span></a>                  <span class="s4">'s'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
<a name="l1736"><span class="ln">1736 </span></a><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1737"><span class="ln">1737 </span></a>    <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">borderHeight </span><span class="s3">+ </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">, </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">],</span>
<a name="l1738"><span class="ln">1738 </span></a>                  <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'s'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
<a name="l1739"><span class="ln">1739 </span></a><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1740"><span class="ln">1740 </span></a>    <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">borderHeight </span><span class="s3">+ </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">, -</span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">],</span>
<a name="l1741"><span class="ln">1741 </span></a>                  <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'s'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
<a name="l1742"><span class="ln">1742 </span></a><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1743"><span class="ln">1743 </span></a>    <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]], [</span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">, </span><span class="s1">borderHeight </span><span class="s3">+ </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
<a name="l1744"><span class="ln">1744 </span></a>                  <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'s'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
<a name="l1745"><span class="ln">1745 </span></a><span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
<a name="l1746"><span class="ln">1746 </span></a>    <span class="s1">CollisionRect</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]], [-</span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">, </span><span class="s1">borderHeight </span><span class="s3">+ </span><span class="s1">borderSize</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
<a name="l1747"><span class="ln">1747 </span></a>                  <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s5">0.001</span><span class="s3">)], </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'s'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
<a name="l1748"><span class="ln">1748 </span></a><span class="s2">for </span><span class="s1">cr </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">5</span><span class="s3">):</span>
<a name="l1749"><span class="ln">1749 </span></a>    <span class="s1">game</span><span class="s3">.</span><span class="s1">collisionRect</span><span class="s3">[</span>
<a name="l1750"><span class="ln">1750 </span></a>        <span class="s3">-</span><span class="s1">cr </span><span class="s3">- </span><span class="s5">1</span><span class="s3">].</span><span class="s1">sf </span><span class="s3">= </span><span class="s5">4  </span><span class="s0"># make points on the collisionRect stop quicker (depends on the point's surface friction as well)</span>
<a name="l1751"><span class="ln">1751 </span></a>
<a name="l1752"><span class="ln">1752 </span></a><span class="s1">game</span><span class="s3">.</span><span class="s1">initLists</span><span class="s3">()  </span><span class="s0"># WARNING: must ALWAYS run this ONCE before vizact.ontimer</span>
<a name="l1753"><span class="ln">1753 </span></a><span class="s1">vizact</span><span class="s3">.</span><span class="s1">ontimer</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">calcRate</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">main</span><span class="s3">)  </span><span class="s0"># calculate physics 'calcRate' times each second</span>
<a name="l1754"><span class="ln">1754 </span></a><span class="s1">vizact</span><span class="s3">.</span><span class="s1">ontimer</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">renderRate</span><span class="s3">, </span><span class="s1">game</span><span class="s3">.</span><span class="s1">render</span><span class="s3">)  </span><span class="s0"># render objects 'renderRate' times each second</span>
<a name="l1755"><span class="ln">1755 </span></a></pre>
</body>
</html>